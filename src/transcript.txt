 Kylie Ying has worked at many interesting places, such as MIT, CERN, and Free Code Camp. She's a physicist, engineer, and basically a genius. And now she's going to teach you about machine learning in a way that is accessible to absolute beginners. What's up you guys? So welcome to machine learning for everyone. If you are someone who is interested in machine learning and you think you are considered as everyone, then this video is for you. In this video we'll talk about supervised and unsupervised learning models. We'll go through maybe a little bit of the logic or math behind them. And then we'll also see how we can program it on Google Colab. If there are certain things that I have done, and you know you're somebody with more experience of me, please feel free to correct me in the comments and we can all as a community learn from this together. So with that, let's just dive right in. Without wasting any time, let's just dive straight into the code and I will be teaching you guys concepts as we go. So this here is the UCI machine learning repository. And basically they just have a ton of data sets that we can access. And I found this really cool one called the magic Gamma Telescope dataset. So in this dataset, if you don't want to read all this information to summarize what I think is going on, is there's this Gamma Telescope. And we have all these higher-energy particles hitting the telescope. Now there's a camera, there's a detector that actually records certain patterns of you know how this light hits the camera. And we can use properties of those patterns in order to predict what type of particle cause that radiation. So whether it was a Gamma particle or some other head like Hadron. Down here, these are all of the attributes of those patterns that we collect in the camera. So you can see that there's you know, some length with size, asymmetry, etc. Now we're going to use all these properties to help us discriminate the patterns and whether or not they came from a Gamma particle or a Hadron. So in order to do this, we're going to come up here, go to the data folder, and you're going to click this magic 04 data and we're going to download that. Now over here, I have a Colab notebook open. So you go to Colab.researchsuckgoogle.com. You start a new notebook and I'm just going to call this the magic dataset. So actually I'm going to call this code camp magic example. Okay. So with that, I'm going to first start with some import. So I will import, you know, I always import NumPy. I always import pandas and I always import map plot live and then we'll import other things as we go. So yeah, we run that. In order to run the cell, you can either click this play button here or you can on my computer. It's just shift enter and that will run the cell. And here I'm just going to order, I'm just going to, you know, let you guys know, okay, this is where I found the dataset. So I've copied and pasted this actually, but this is just where I found the dataset. And in order to import that downloaded file that we got from the computer, we're going to go over here to this folder thing. And I am literally just going to drag and drop that file into here. Okay. So in order to take a look at, you know, what does this file consist of, do we have the labels? Do we not? I mean, we could open it our computer, but we can also just do pandas, read CSV and we can pass in the name of this file and let's see what it returns. So it doesn't seem like we have the label. So let's go back to here. I'm just going to make the columns, the column labels, all of these attribute names over here. So I'm just going to take these values and make that the column names. All right, how do I do that? So basically, I will come back here and I will create a list called calls and I will type in all of those things with F size, F, Pong, and we also have F, Pong, Pong, Pong. We have F symmetry, F, M, Pong. F, M, F, M, MAC, M 3, F, P inæ•¸ and F, L. Okay. Great, now, in order to label those as these columns down here in our data frame. So basically this command spiritually reads some CSV file that you pass in. CSV has come about comma separated values, and turns that into a pandas data frame object. So now if I pass in a names here, then it basically assign these labels to the columns of this data set. So I'm gonna set this data frame equal to DF, and then if we call, so head is just like, give me the first five things. Now you'll see that we have labels for all of these. Okay? All right, great. So one thing that you might notice is that over here, the class labels, we have G and H. So if I actually go down here, and I do data frame, class.unique, you'll see that I have either Gs or Hs and these stand for gammas or hat runs. And our computer is not so good at understanding letters, but our computer is really good at understanding numbers. So what we're going to do is we're going to convert this to zero for G and one for H. So here I'm gonna set this equal to this, whether or not that equals G, and then I'm just going to say as type int. So what this should do is convert this entire column. If it equals G, then this is true. So I guess that would be one, and then if it's H, it would be false, so that would be zero. But I'm just converting G and H to one and zero. It doesn't really matter if G is one and H is zero, or vice versa. Let me just take a step back right now and talk about this data set. So here I have some data frame, and I have all of these different values for each entry. Now, this is, each of these is one sample. It's one example. It's one item in our data set. It's one data point. All of these things are kind of the same thing. When I mention, oh, this is one example, or this is one sample, or whatever. Now, each of these samples, they have one quality for each, or one value for each of these labels up here, and then it has the class. Now, what we're going to do in this specific example is try to predict for future samples, whether the class is G for gamma or H for Hadron, and that is something known as classification. Now, all of these up here, these are known as our features, and features are just things that we're going to pass into our model in order to help us predict the label, which in this case is the class column. So, for sample zero, I have 10 different features, so I have 10 different values that I can pass into some model, and I can spit out the class, the label. And I know the true label here is G, so this is actually supervised learning. All right, so before I move on, let me just give you a quick little crash course on what I just said. This is machine learning for everyone. Well, the first question is what is machine learning? Well, machine learning is a subdomain of computer science that focuses on certain algorithms, which might help a computer learn from data, without a programmer being there telling the computer exactly what to do. That's what we call explicit programming. So you might have heard of AI and ML and data science, what is the difference between all of these? So AI is artificial intelligence, and that's an area of computer science, where the goal is to enable computers and machines to perform human-like tasks and simulate human behavior. Now machine learning is a subset of AI. That tries to solve one specific problem and make predictions using certain data. And data science is a field that attempts to find patterns and draw insights from data. And that might mean we're using machine learning. So all of these fields kind of overlap and all of them might use machine learning. So there are a few types of machine learning. The first one is supervised learning. And in supervised learning, we're using labeled inputs. So this means whatever input we get, we have a corresponding output label in order to train models and to learn outputs of different new inputs that we might feed our model. So for example, I might have these pictures. Okay, to a computer, all these pictures are pixels. They're pixels with a certain color. Now in supervised learning, all of these inputs have a label associated with them. This is the output that we might want the computer to be able to predict. So for example, over here, this picture is a cat. This picture is a dog. And this picture is a lizard. Now there's also unsupervised learning. And in unsupervised learning, we use unlabeled data to learn about patterns in the data. So here are my input data points. Again, they're just images, they're just pixels. Well, okay, let's say I have a bunch of these different pictures. And what I can do is I can feed all these to my computer. And I might not, you know, my computer's not going to be able to say, oh, this is a cat dog and lizard in terms of, you know, the output. But it might be able to cluster all these pictures. It might say, hey, all of these have something in common. All of these have something in common. And then these down here have something in common. That's finding some sort of structure in our unlabeled data. And finally, we have reinforcement learning. And reinforcement learning, well, they usually there's an agent that is learning in some sort of interactive environment based on rewards and penalties. So let's think of a dog. We can train our dog. But there's not necessarily, you know, any wrong or right I'll put at any given moment, right? Well, let's pretend that dog is a computer. Essentially what we're doing is we're giving rewards to our computer and tell your computer, hey, this is probably something good that you want to keep doing. We'll a computer agent, yeah, terminology. But in this class today, we'll be focusing on supervised learning and unsupervised learning and learning different models for each of those. All right, so let's talk about supervised learning first. So this is kind of what a machine learning model looks like. You have a bunch of inputs that are going into some model. And then the model is spitting out an output, which is our prediction. So all these inputs, this is what we call the feature vector. Now, there are different types of features that we can have. We might have qualitative features. And qualitative means categorical data. There's either a finite number of categories or groups. So one example of a qualitative feature might be gender. And in this case, there's only two here. It's for the sake of the example. I know this might be a little bit outdated. Here we have a girl and a boy. There are two genders. There are two different categories. That's a piece of qualitative data. Another example might be, okay, we have a bunch of different nationalities, maybe a nationality or a nation or a location. That might also be an example of categorical data. Now, in both of these, there's no inherent order. It's not like we can rate US, one, and France, two, Japan, three, et cetera, right? There's not really any inherent order built into either of these categorical data sets. That's why we call this nominal data. Now, for nominal data, the way that we want to feed it into our computer is using something called one hot encoding. So let's say that I have a data set. Some of the items in our data, some of the inputs might be from the US. So it might be from India than Canada, than France. Now, how do we get our computer to recognize that? We have to do something called one hot encoding. And basically one hot encoding is saying, okay, well, if it matches some category, make that a one, and if it doesn't, just make that a zero. So for example, if your input were from the US, you might have one zero zero zero. India, you know, zero one zero zero. Canada, okay, well, the item representing Canada is one, and then France, the item representing France is one. And then you can see that the rest are zeroes. That's one hot encoding. Now, there are also a different type of qualitative feature. So here on the left, there are different age groups. There's babies, toddlers, teenagers, young adults, adults, and so on, right? And on the right hand side, we might have different ratings. So maybe bad, not so good, mediocre, good, and then like great. Now, these are known as ordinal pieces of data, because they have some sort of inherent order, right? Like being a toddler is a lot closer to being a baby than being an elderly person, right? Or good is closer to great than it is to really bad. So these have some sort of inherent ordering system. And so for these types of data sets, we can actually just mark them from, you know, one to five, or we can just say, hey, for each of these, let's give it a number. And this makes sense because like, for example, the thing that I just said, how good is closer to great, then good is close to not, good at all, well, force closer to five and four is close to one. So this actually kind of makes sense. And it'll make sense for the computer as well. All right, there are also quantitative pieces of data. And quantitative pieces of data are numerical valued pieces of data. So this could be discrete, which means, you know, they might be integers, or it could be continuous, which means all real numbers. So for example, the length of something is a quantitative piece of data. It's a quantitative feature. The temperature of something is a quantitative feature. And then maybe how many Easter eggs I collected in my basket, this Easter egg hunt, that is an example of discrete quantitative feature. Okay, so these are continuous. And this over here is the screen. So those are the things that go into our feature vector. Those are our features that we're feeding this model. Because our computers are really, really good at understanding math, right, at understanding numbers. They're not so good at understanding things that humans might be able to understand. Well, what are the types of predictions that our model can output? So in supervised learning, there are some different tasks. There's one classification. And basically classification just saying, okay, predict discrete classes. And that might mean, you know, this is a hotdog. This is a pizza, and this is ice cream. Okay, so there are three distinct classes and any other pictures of hot dogs, pizza or ice cream, I can put under these labels. Hot dog pizza ice cream. This is something known as multi-class classification. But there's also binary classification. And binary classification, you might have hot dog, or not hot dog. So there's only two categories that you're working with. Something that is something and something that isn't binary classification. Okay, so yeah, other examples. So if something has positive or negative sentiment, that's binary classification. Maybe you're predicting your pictures if they're cats or dogs. That's binary classification. Maybe you are writing an email filter and you're trying to figure out if an email spam or not spam. So that's also binary classification. Now for multi-class classification, you might have, you know, cat dog, loser, dolphin, shark, rabbit, et cetera. We might have different types of fruit to like orange, apple, pear, et cetera. And then maybe different plant species. But multi-class classification just means more than two. And binary means we're predicting between two things. There's also something called regression when we talk about supervised learning. And this just means we're trying to predict continuous values. So instead of just trying to predict different categories, we're trying to come up with a number that is on some sort of scale. So some examples. So some examples might be the price of Ethereum tomorrow, or it might be, okay, what is going to be the temperature? Or it might be what is the price of this house? So these things don't really fit into discrete classes. We're trying to predict a number that's as close to the true value as possible using different features of our data set. So that's exactly what our model looks like in supervised learning. Now let's talk about the model itself. How do we make this model learn? Or how can we tell whether or not it's even learning? So before we talk about the models, let's talk about how can we actually evaluate these models or how can we tell whether something is a good model or bad model? So let's take a look at this data set. So this data set has, this is from a diabetes, a human Indian diabetes data set. And here we have different number of pregnancies, different glucose levels, blood pressure, skin thickness, insulin, BMI, age, and then the outcome, whether or not they have diabetes. One for they do, zero for they don't. So here, all of these are quantitative features, right, because they're all on some scale. So each row is a different sample in the data. So it's a different example. It's one person's data. And each row represents one person in the data set. Now this column, each column represents a different feature. So this one here is some measure of blood pressure levels. And this one over here, as we mentioned, is the output label. So this one is whether or not they have diabetes. And as I mentioned, this is what we would call a feature vector because these are all of our features in one sample. And this is what's known as the target or the output for that feature vector. That's what we're trying to predict. And all of these together is our features matrix, X. And over here, this is our labels or targets vector, Y. So I've condensed this to a chocolate bar to kind of talk about some of the other concepts in machine learning. So over here, we have our X, our features matrix. And over here, this is our label Y. So each row of this will be fed into our model. And our model will make some sort of prediction. And what we do is we compare that prediction to the actual value of Y that we have in our label data set because that's a whole point of supervised learning is we can compare what our models are putting to, oh, what is the truth actually? And then we can go back and we can adjust some things so that the next iteration, we get closer to what the true value is. So that whole process here, the tinkering, the, okay, what's the difference? Where did we go wrong? That's what's known as training the model. All right, so take this whole chunk right here. Do we want to really put our entire chocolate bar into the model to train our model? Not really, right, because if we did that, then how do we know that our model can do well on new data that we haven't seen? Like if I were to create a model to predict whether or not someone has diabetes, let's say that I just train all my data and I see that all my training data does well. I go to some hospital and I'm like, here's my model. I think you can use this to predict if somebody has diabetes. Do we think that would be effective or not? Probably not, right, because we haven't assessed how well our model can generalize. Okay, it might do well after our model has seen this data over and over again, but what about new data? Can our model handle new data? Well, how do we get our model to us? We've got to assess that. So we actually break up our whole data set that we have into three different types of data sets. We call it the training data set, the validation data set, and the testing data set. And you might have 60% here, 20% and 20% or 80, 10, and 10. It really depends on how many statistics you have, I think either of those would be acceptable. So what we do is then we feed the training data set into our model. We come up with, this might be a vector of predictions, corresponding with each sample that we put into our model. We figure out, okay, what's the difference between our prediction and the true values? This is something known as loss. Loss is, you know, what's the difference here in some numerical quantity, of course. And then we make adjustments, and that's what we call training. Okay. So then, once we've made a bunch of adjustments, we can put our validation set through this model. And the validation set is kind of used as a reality check, during or after training, to ensure that the model can handle unseen data still. So every single time after we train one iteration, we might stick the validation set in and see, hey, what's the loss there? And then after our training's over, we can assess the validation set and ask, hey, what's the loss there? But one key difference here is that we don't have that training step. This loss never gets fed back into the model. Right, that feedback loop is not closed. All right, so let's talk about loss really quickly. So here I have four different types of models. I have some sort of data that's being fed into the model and then some output. Okay, so this output here is pretty far from, you know, this truth that we want. And so this loss is going to be high. It model B. Again, this is pretty far from what we want. So this loss is also gonna be high. Let's give it 1.5. Now this one here, it's pretty close. I mean, maybe not almost, but pretty close to this one. So that might have a loss of 0.5. And then this one here is maybe further than this, but still better than these two. So that loss might be 0.9. Okay, so which of these model performs the best? Well, model C has a smallest loss, so it's probably model C. Okay, now let's take model C after, you know, we've come up with these, all these models and we've seen, okay, model C is probably the best model. We take model C and we run our test set through this model. And this test set is used as a final check to see how generalizable that chosen model is. So if I, you know, finish training my diabetes data set, then I could run it through some chunk of the data and I can say, oh, like this is how we perform on data that it's never seen before at any point during the training process, okay? And that loss, that's a final reported performance of my test set, or this would be the final reported performance of my model. Okay, so let's talk about this thing called loss because I think I kind of just glossed over it, right? So loss is the difference between your prediction and the actual, like, label. So this would give us slightly higher loss than this. And this would even give a higher loss because it's even more off in computer science, we like formulas, right? We like formulaic ways of describing things. So here are some examples of loss functions and how we can actually come up with numbers. This here is known as L1 loss. And basically L1 loss just takes the absolute value of whatever your real value is, whatever the real output label is, subtracts the predicted value and takes the absolute value of that, okay? So the absolute value is a function that looks something like this. So the further off you are, the greater your losses, right? And either direction. So if your real value is off from your predicted value by 10, then your loss for that point would be 10. And then this sum here just means, hey, we're taking all the points in our data set and we're trying to figure out the sum of how far everything is. Now we also have something called L2 loss. So this loss function is quadratic, which means that if it's close, the penalty is very minimal and if it's off by a lot, then the penalty is much, much higher, okay? And this instead of the absolute value, we just square the difference between the two. Now there's also something called binary cross entropy loss. It looks something like this and this is for binary classification. This might be the loss that we use. So this loss, I'm not gonna really go through it too much, but you need to know that loss decreases as the performance gets better. So there are some other measures of performance, as well. So for example, accuracy, what is accuracy? So let's say that these are pictures that I'm feeding my model, okay? And these predictions might be Apple Orange Orange Apple. Okay, but the actual is Apple Orange Apple Apple. So three of them were correct and one of them was incorrect. So the accuracy of this model is three quarters or 75%. All right, coming back to our collab notebook, I'm going to close this a little bit. Again, we've imported stuff up here and we've already created our data frame right here. And this is all of our data. This is what we're going to use to train our models. So down here, again, if we now take a look at our data set, you'll see that our classes are now zeroes and ones. So now this is all numerical, which is good, because our computer can now understand that. Okay, and you know, it would probably be a good idea to maybe kind of plot, hey, do these things have anything to do with the class. So here I'm going to go through all the label. So for label in the columns of this data frame, so this just gets me the list. Actually, we have the list, right? It's called, so let's just use that. It might be less confusing. Of everything up till the last thing, which is the class. So I'm going to take all these 10 different features. And I'm going to plot them as a histogram. So now I'm going to plot them as a histogram. So basically, if I take that data frame, and I say, okay, for everything where the class is equal to one. So these are all of our gammas, remember. Now for that portion of the data frame, if I look at this label. So now these, okay, what this part here is saying, is inside the data frame, get me everything where the class is equal to one. So that's all of these would fit into that category, right? And now let's just look at the label column. So the first label would be F length, which would be this column. So this command here is getting me all the different values that belong to class one for this specific label. And that's exactly what I'm going to put into the histogram. And now I'm just going to tell my plot lid, make the color blue, make label this as gamma set alpha. Why do I keep doing that? Alpha equal to 0.7. So that's just like the transparency. And then I'm going to set density equal to true so that when we compare it to the have rods here, we'll have a baseline for comparing them. Okay, so the density being true just basically normalizes these distributions. So if you have 200 in one type and then 50 of another type, well if you drew the histogram, it would be hard to compare because one of them would be a lot better than the other, right? But by normalizing them, we kind of are distributing them over how many samples are. All right, and then I'm just going to put a title on here, make that the label, the while label. So because it's density, the while label is probability. And the x label is just going to be the label. What is going on? And I'm going to include a legend and PLT.show just means okay, display the plot. So if I run that, just be up to the last item. So we want a list, right, not just the last item. And now we can see that we're plotting all of these. So here we have the length, oh, and I made this gamma. So this should be had on. Okay, so the gamma's and blue, the have drones are in red. So here we can already see that maybe if the length is smaller, it's probably more likely to be gamma, right? And we can kind of, you know, these all look somewhat similar. But here, okay, clearly if there's more asymmetry, or if, you know, this asymmetry measure is larger, then it's probably hadron. Okay, oh, this one's a good one. So F alpha seems like hadrons are pretty evenly distributed, whereas if this is smaller, it looks like there's more gamma than that area. Okay, so this is kind of what the data that we're working with. We can kind of see what's going on. Okay, so the next thing that we're going to do here is we are going to create our train, our validation, and our test datasets. I'm going to set train, valid, and test to be equal to this, so numpy dot split, I'm just splitting up the data frame. And if I do this sample where I'm sampling everything, this will basically shuffle my data. Now, if I want to pass in where exactly I'm splitting my data set, so the first split is going to be maybe at 60%. So I'm just going to say 0.6 times the length of this data frame. So, and then cast that 10 integer. That's going to be the first place where, you know, I cut it off, and that'll be my training data. Now, if I then go to 0.8, this basically means everything between 60% and 80% of the length of the data set will go towards validation, and then like everything from 80 to 100 is going to be my test data. So I can run that. And now, if we go up here and we inspect this data, we'll see that these columns seem to have values in like the 100s, whereas this one is 0.03. Right, so the scale of all these numbers is way off, and sometimes that will affect our results. So one thing that we would want to do is scale these so that they are, so that it's now relative to maybe the mean and the standard deviation of that specific column. I'm going to create a function called scale data set. And I'm going to pass in the data frame and that's what I'll do for now. Okay, so the x values are going to be, you know, I take the data frame, and let's assume that the columns are going to be, you know, that the label will always be the last thing in the data frame. So what I can do is say dataframe.coms all the way up to the last item. And get those values. Now for my y, well, it's the last column, so I can just do this. I can just index into that last column and then get those values. Now in, so I'm actually going to import something known as the standard scalar from SK learn. So if I come up here, I can go to SK learn.preprocessing and I'm going to import standard scalar. I have to run that cell. I'm going to come back down here and now I'm going to create a scalar and use that script or so standard scalar. And with the scalar, what I can do is actually just fit and transform x. So here, I can say x is equal to scalar.fit, fit, transform, x. So what that's doing is saying, okay, take x and fit the standard scalar to x, and then transform all those values and what would it be? And that's going to be our new x. All right. And then I'm also going to just create, you know, the whole data as one huge 2D numpy array. And in order to do that, I'm going to call hstack. So hstack is saying, okay, take an array and another array and horizontally stack them together. That's what the hstans for. So by horizontally stack them together, just like put them side by side. Okay, not on top of each other. So what am I stacking? Well, I have to pass in something to do so that we can stack x and y. And now Okay, so numpy is very particular about dimensions, right? So in this specific case, our x is a two dimensional object, but y is only a one dimensional thing. It's only a vector of values. So in order to now reshape it into a 2D item, we have to call numpy dot reshape. And we can pass in the dimensions of its reshape. So if I pass a negative 1 comma 1, that just means, okay, make this a 2D array, where the negative 1 just means infer what this dimension value would be, which ends up being the length of y. This would be the same as literally doing this, but the negative 1 is easier because we're making the computer do the hard work. So if I stack that, I'm going to then return the data x and y. Okay, so one more thing is that if we go into our training dataset, again, this is our training dataset, and we get the length of the training dataset, but where the training datasets class is one. So remember that this is the gamas. And then if we print that, and we do the same thing but zero, we'll see that, there's around 7,000 of the gamas, but only around 4,000 of the hatrons. So that might actually become an issue. And instead, what we want to do is we want to over sample our training dataset. So that means that we want to increase the number of these values so that these kind of match better. And surprise surprise, there is something that we can import that will help us do that. So I'm going to go to from inblurn.oversampling, and I'm going to import this random over sampler. Run that cell and come back down here. So I will actually add in this parameter called over sample and set that to false for default. And if I do want to over sample, then what I'm going to do and by over sample, so if I do want to over sample, then I'm going to create this ROS and set it equal to this random over sampler. And then for X and Y, I'm just going to say, okay, just fit and re sample X and Y. And what that's doing is saying, okay, take more of the less class. So take take the less class and keep sampling from there to increase the size of our dataset of that smaller class. So that's been now match. So if I do this and I scale dataset and I pass in the training dataset where over sample is true. So this, let's say this is train and then X train Y train. Oops, what's going on? Oh, these should be columns. So basically what I'm doing now is I'm just saying, okay, what is the length of Y train? Okay, now it's 14,800, whatever. And now let's take a look at how many of these are type one. So actually we can just sum that up. And then we'll also see that if we instead switch the label and ask how many of them are the other type, it's the same value. So now these have been evenly, you know, rebalanced. Okay, well, okay, so here I'm just going to make this the validation dataset and then the next one. I'm going to make this the test dataset. All right, and we're actually going to switch over sample here to false. Now the reason why I'm switching that to false is because my validation and my tests are for the purpose of, you know, if I have data that I haven't seen yet, how does my sample perform on those? And I don't want to over sample for that right now. Like I don't care about balancing those. I want to know if I have the random set of data that's unlabeled, can I trust my model, right? So that's why I'm not over sampling. I run that and again, what is going on? It's because we already have this train. So I have to come up here and split that data frame again. And now let's run these. Okay. So now we have our data properly formatted. And we're going to move on to different models now. And I'm going to tell you guys a little bit about each of these models. And then I'm going to show you how we can do that in our code. So the first model that we're going to learn about is can and or can nearest neighbors. Okay. So here I've already drawn a plot. On the y-axis, I have the number of kids that a family might have. And then on the x-axis, I have their income in terms of thousands per year. So, you know, if someone's making 40,000 a year, that's where this would be. And if somebody they could 320, that's where that would be. So if he has zero kids, it'd be somewhere along this axis. Somebody has five. It'd be somewhere over here. Okay. And now I have these plus signs and these minus signs on here. So what I'm going to represent here is the plus sign means that they own a car. And the minus sign is going to represent no car. Okay. So your initial thought should be, okay, I think this is binary classification. Because all of our points, all of our samples have labels. So this is a sample with the plus label. And this here is another sample with the minus label. This is an abbreviation for a width that I'll use. All right. So we have this entire data set and maybe around half the people own a car and maybe around half the people don't own a car. Okay. Well, what if I had some new point? Let me use choose a different color. I'll use this nice green. Well, what if I have a new point over here? So let's say that somebody makes 40,000 a year and has two kids. What do we think that would be? Well, just logically looking at this plot, you might think, okay, it seems like they wouldn't have a car, right? Because that kind of matches a pattern of everybody else around them. So that's a whole concept of this nearest neighbors is you look at, okay, what's around you? And then you're basically like, okay, I'm going to take the label of the majority. That's around me. So the first thing that we have to do is we have to define a distance function. And a lot of times in 2D plots like this, our distance function is something known as Euclidean distance. And Euclidean distance is basically just the straight line distance like this. Okay, so this would be the Euclidean distance. It seems like there's this point, there's this point, there's that point, etc. So the length of this line, this green line that I just drew, that is what's known as Euclidean distance. If we want to get technical with that this exact formula is the distance here, let me zoom in. The distance is equal to the square root of 1.x minus the other points x squared plus x then that's where root. The same thing for y. So y1, 1 minus y2 of the other squared. Okay, so we're basically trying to find the length, the distance is the difference between x and y. And then square each of those sum it up and take the square root. Okay, so I'm going to erase this so it doesn't clutter my drawing. But anyways, now going back to this plot. So here in the nearest neighbor algorithm, we see that there is a k, right? And this k is basically telling us, okay, how many neighbors do we use in order to judge what the label is? So usually we use a k of maybe, you know, 3 or 5 to depend on how bigger data set is. But here I would say maybe a logical number would be 3 or 5. So let's say that we take k to be equal to 3. Okay, well, of this data point that I drew over here, let me use green to highlight this. Okay, so of this data point that I drew over here, it looks like the 3 closest points are definitely this one, this one. And then this one has a length of 4 and this one seems like it'd be a little bit further than 4. So actually this would be, these would be our 3 points. Well, all those points are blue. So chances are my prediction for this point is going to be blue. It's going to be probably going to have a car. All right, now what if my point is somewhere? What if my point is somewhere over here? Let's say that a couple has 4 kids and they may 240,000 to year. All right, well now my closest points are this one. Probably a little bit over that one and then this one. Right, okay, still all pluses. Well, this one is more than likely to be plus. All right, now let me get rid of some of these just so that it looks a little bit more clear. All right, let's go through one more. What about a point that might be right here? Okay, let's see. Well, definitely this is the closest. Right, this one is also closest. And then it's really close between the two of these. But if we actually do the mathematics, it seems like if we zoom in, this one is right here and this one is in between these two. So this one here is actually shorter than this one. And that means that that top one is the one that we're going to take. Now what is the majority of the points that are close by? Well, we have one plus here, we have one plus here and we have one minus here, which means that the pluses are the majority. And that means that this label, is probably somebody with a car. Okay, so this is how K nearest neighbors would work. It's that simple. And this can be extrapolated to further dimensions, to higher dimensions. You know, if you have here, we have two different features. We have the income, and then we have the number of kids. But let's say we have 10 different features. We can expand our distance function, so that it includes all 10 of those dimensions. We take the square root of everything. And then we figure out which one is the closest to the point that we desire to classify. Okay? So that's K nearest neighbors. So now we've learned about K nearest neighbors. Let's see how we would be able to do that within our code. So here I'm going to label the section, K nearest neighbors. And we're actually going to use a package from SK learn. So the reason why we, you know, use these packages is so that we don't have to manually code all these things ourselves because it would be really difficult and chances are the way that we would code it, either we have bugs or it would be really slow or I don't know a whole bunch of issues. So what we're going to do is hand it off to the pros. From here I can say, okay, from SK learn, which is this package, not neighbors. I'm going to import K neighbors classifier because we're classifying. Okay? So I've run that. And our K and N model is going to be this K neighbors classifier, and we can pass in a parameter of how many neighbors, you know, we want to use. So first let's see what happens if we just use one. So now if I do K and N model dot fit, I can pass in my X training set and my Y train data. Okay? So that effectively fits this model. And let's get all the predictions. So Y can and I guess yeah, let's do Y predictions. And my Y predictions are going to be a can and model dot predict. So let's use the test set X test. Okay? All right, so if I call my predict, you'll see that we have those, but if I get my truth values for that test set, you'll see that this is what we actually do. So just like, as we got five out of six, I'm okay. Great. So let's actually take a look at something called the classification report that's offered by SK learn. So if I go to from SK learn dot metrics, import classification report, what I can actually do is say, hey, print out this classification report for me and let's check, you know, I'm giving you the Y test and the Y prediction. We run this and we see we get this whole entire chart. So I'm going to tell you guys a few things on this chart. All right, this accuracy is 82%, which is actually pretty good. That's just saying, hey, if we just look at, you know, what each of these new points, what it's closest to, then we actually get an 82% accuracy, which means how many do we get right versus how many total are there. Now precision is saying, okay, you might see that we have it for a class one or class zero and class one. What precision is saying, let's go to this Wikipedia diagram over here because I actually kind of like this diagram. So here, this is our entire data set and on the left over here, we have everything that we know is positive. So everything that is actually truly positive that we've labeled positive in our original data set and over here, this is everything that's truly negative. Now in the circle, we have things that are that were labeled positive by our model. On the left here, we have things that are truly positive because, you know, this side is the positive side and the side is the negative side. So these are truly positive, whereas all these ones out here, well, they should have been positive, but they are labeled as negative. And in here, these are the ones that we've labeled positive, but they're actually negative. And out here, these are truly negative. So precision is saying, okay, out of all the ones, we've labeled as positive, how many of them are true positives. And recall is saying, okay, out of all the ones that we know are truly positive, how many do we actually get right? Okay, so going back to this over here are precision score. So again, precision, out of all the ones that we've labeled as this specific class, how many of them are actually that class? It's 77-84%. Now recall how out of all the ones that are actually this class, how many of those that we get, this is 68% and 89%. All right, so not too shabby, we clearly see at this recall and precision for like the class zero is worse than class one, right? So that means for Hadron, it's worked for Hadron and for our game was. This F1 score over here is kind of a combination of the precision and recall score. So we're actually going to mostly look at this one because we have an unbalanced test dataset. So here we have a measure of 72 and 87 or 0.72 and 0.87, which is not too shabby. All right, well, what if we, you know, made this three? So we actually see that, okay, so what was it originally with one? We see that our F1 score, you know, is now it was 0.72 and then 0.87 and then our accuracy was 82%. So if I change that to three, all right, so we've kind of increased zero at the class of one and then our overall accuracy is 81. So let's actually just make this five. All right, so, you know, again, very similar numbers, we have 82% accuracy, which is pretty decent for a model that's relatively simple. Okay, the next type of model that we're going to talk about is something known as naive base. Now in order to understand the concepts behind naive base, we have to be able to understand conditional probability and base rule. So let's say I have some sort of data set that's shown in this table right here. People who have COVID are over here in this red row and people who do not have COVID are down here in this green row. Now what about the COVID tests? Well, people who have tested positive are over here in this column and people who have tested negative are over here in this column. Okay, yeah. So basically our categories are people who have COVID and test positive. People who don't have COVID but test positive, so it falls positive. People who have COVID and test negative, which is a false negative, and people who don't have COVID and test negative, which good, we don't have COVID. Okay, so let's make this slightly more legible. And here in the margins, I've written down the sums of whatever it's referring to. So this here is a sum of this entire row and this here might be the sum of this column over here. Okay, so the first question that I have is what is the probability of having COVID given that you have a positive test. And in probability, we write that out like this. So the probability of COVID given, so this line that vertical line means given that, you know, some condition. So given a positive test. Okay, so what is the probability of having COVID given a positive test? So what this is asking is saying, okay, let's go into this condition. So the condition of having a positive test, that is this slice of the data, right? That means if you're in this slice of data, you have a positive test. So given that, we have a positive test given in this condition, in this circumstance, we have a positive test. So what's the probability that we have COVID? Well, if we're just using the state of the number of people that have COVID is 531. So I'm going to say that there's 531 people that have COVID. And then now we divide that by the total number of people that have a positive test, which is 551. Okay, so that's the probability and doing a quick division. We get that this is equal to around 96.4%. So according to this data set, which is data that I made up off the top of my head, so it's not actually real COVID data. But according to the data, the probability of having COVID given that you test a positive is 96.4%. All right, now with that, let's talk about phase rule, which is this section here. Let's ignore this bottom part for now. So phase rule is asking, okay, what is the probability of some event a happening? Given that b happened. So this, we are know has happened. This is our condition, right? Well, what if we don't have data for that, right? Like, what if we don't know what the probability of a given b is? Well, b is rule is saying, okay, well, you can actually go and calculate it as long as you have a probability of b given a, the probability of a and the probability of b. Okay, and this is just a mathematical formula for that. All right, so here we have phase rule and let's actually see b's rule in action. Let's use it on an example. So here, let's say that we have some disease statistics, okay? So knock over different disease and we know that the probability of obtaining a false positive is 0.05, probability of obtaining a false negative is 0.01 and the probability of the disease is 0.1. Okay, what is the probability of the disease given that we got a positive test? How do we even go about solving this? So what do I mean by false positive? What's a different way to rewrite that? A false positive is when you test positive, but you don't actually have the disease. So this here is a probability that you have a positive test given no disease, right? And similarly for the false negative, it's a probability that you test negative given that you actually have the disease. So if I put that into a chart, for example, and this might be my positive and negative tests and this might be my diseases, disease and no disease. Well, the probability that I test positive, but actually have no disease, okay? That's 0.05 over here and then the false negatives up here for 0.01. So I'm testing negative, but I don't actually have the disease. So the probability that you test positive and you don't have the disease, plus the probability that you test negative given that you don't have the disease. That should sum up to 1, okay? Because if you don't have the disease, then you should have some probability that you're testing positive and some probably that you're testing negative, but that probability in total should be 1. So that means that the probability of negative in and no disease, this should be the reciprocal, this should be the opposite. So it should be 0.95 because it's 1 minus whatever this probability is. And then similarly, oops. Up here, this should be 0.99 because the probability that we, you know, test negative and have the disease plus the probability that we test positive and have the disease should equal one. So this is our probability chart. And now this probability of disease being 0.1 just means I have 10% probability of actually having the disease, right? Like in the general population, the probability that I have the disease is 0.1. Okay. So what is the probability that I have the disease given that I got a positive, I got a positive test? Well, remember that we can write this out in terms of phase rule, right? So if I use this rule up here, this is a probability of a positive test given that I have the disease times the probability of the disease divided by the probability of the evidence, which is my positive test. All right. Now let's plug in some numbers for that. The probability of having a positive test given that I have the disease is 0.99. And then the probability that I have the disease is this value over here, 0.1. Okay. And then the probability that I have a positive test at all should be, okay, what is the probability that I have a positive test given that I actually have the disease and then having the disease? And then the other case where the probability of me having a negative test given, sorry, positive test giving no disease times the probability of not actually having a disease. Okay. So I can expand that probability of having positive test out into these two different cases. I have a disease and then I don't. And then what's the probability of having positive test in either one of those cases? So that expression would become 0.99 times 0.1 plus 0.05. So that's a probability that I'm testing positive but don't have the disease. And in times of probability that I don't actually have the disease. So that's one minus 0.1. So probability that the population of the have the disease is 90%. So 0.9. And let's do that multiplication. And I get an answer of 0.6875 or 68.75%. Okay. All right. So we can actually expand that. We can expand Bay's rule and apply it to classification. And this is what we call naive base. So first a little terminology. So the posterior is this over here because it's asking, hey, what is the probability of some class CK? So by CK, I just mean, you know, the different categories. So C for category or class or whatever. So category one might be cats. Category two dogs. Category three lizards. All the way, we have K categories. K is just some number. Okay. So what is the probability of having of this specific sample X? So this is our feature vector of this one sample. What is the probability of X fitting into category one two three for whatever? Right. So that's what this is asking. What is the probability that, you know, it's actually from this class given all this evidence that we see, the X's. So the likelihood is this quantity over here, it's saying, okay, well given that, you know, assume, assume we are assume that this class is class CK. Okay, assume that this is a category. Well, what is a likelihood of actually seeing X? All these different features from that category. And then this here is the prior. So like in the entire population of things, what are the probabilities? What is the probability of this class in general? Like if I have, you know, in my higher data set, what is the percentage? What is the chance that this image is a cat? How many cats do I have? Right. And then this down here is called the evidence because what we're trying to do is we're changing our prior. We're creating this new posterior probability built upon the prior by using some sort of evidence. Right. And that evidence is a probability of X. So that's some vocab. And this here is the rule for naive phase. Well, okay, let's digest that a little bit, okay. So what is, let me use a different color. What is this side of the equation asking? It's asking, what is the probability that we are in some class K? CK? Given that, you know, this is my first input. This is my second input. This is, you know, my third fourth. This is my end input. So let's say that our classification is, do we play soccer today or not? Okay, and let's say our X's are, okay, is it how much wind is there? How much rain is there? And what day of the week is it? So let's say that it's raining. It's not windy, but it's Wednesday. Do we play soccer or do we not? So let's use base rule on this. So this here is equal to the probability of X1, X2, all these joint probabilities, given class K, times the probability of that class, all over the probability of this evidence. Okay. So what is this fancy symbol over here? This means proportional to. So how our equal sign means it's equal to this like little squiggly sign means that this is proportional to. Okay, and this denominator over here, you might notice that it has no impact on the class. Like this, that number doesn't depend on the class, right? So this is going to be constant for all of our different classes. So what I'm going to do is make things simpler. So I'm just going to say that this probability, X1, X2, all the way to Xn, this is going to be proportional to the numerator. I don't care about the denominator because it's the same for every single class. So this is proportional to X1, X2, Xn, given class K times the probability of that class. Okay. All right. So in naive base, the point of it being naive is that we're actually this joint probability, we're just assuming that all of these different things are all independent. So in my soccer example, the probability that we're playing soccer or the probability that it's windy and it's rainy and it's Wednesday. All of these things are independent. We're assuming that they're independent. So that means that I can actually write this part of the equation here this. So each term in here, I can just multiply all them together. So the probability of the first feature given that it's class K times the probability of second feature given that's like class K all the way up until, you know, the end feature given that it's class K. So this expands to all of this. All right. Which means that this here is now proportional to the thing that we just expanded times this. So I'm going to write that out so the probability of that class and I'm actually going to use this symbol. So what this means is it's a huge multiplication. It means multiply everything to the right of this. So this probability x given some class K. But do it for all the i. So i, what is i? Okay, we're going to go from the first x i all the way to the end. So that means for every single i, we're just multiplying these probabilities together. And that's where this up here comes from. So to wrap this up, this should be a line. To wrap this up in plain English, basically what this is saying is a probability that, you know, we're in some category given that we have all these different features is proportional to the probability of that class in general times the probability of each of those features given that we're in this one class that we're testing. So the probability of it, you know, of us playing soccer today given that it's rainy not windy and and it's Wednesday is proportional to okay well what is what is the probability that we play soccer anyways? And then times the probability that it's rainy given that we're playing soccer times the probability that it's not windy given that we're playing soccer. So how many times are we playing soccer when it's windy, how you know, and then how many times or what's the probability that's Wednesday given that we're playing soccer? Okay, so how do we use this in order to make a classification? So that's where this comes in. Our y hat, our predicted y is going to be equal to something called the arg max. And then this expression over here because we want to take the arg max, well we want. So okay if I write out this again this means the probability of being in some class CK given all of our evidence. Well we're going to take the decay that maximizes this expression on the right. That's what arg max means. So if k is in 0, oops, 1 through k. So this how many categories are? We're going to go through each k and we're going to solve this expression over here and find the k that makes that the largest. Okay and remember that instead of writing this we have now a formula thanks to Bay's rule for helping us approximate that right and something that maybe we can we maybe we have like the evidence for that we have the answers for that based on our training set. So this principle of going through each of these and finding whatever class whatever category maximizes this expression on the right. This is something known as m ap for short or maximum a posteriori. Pick the hypothesis so pick the k that is the most probable so that we minimize the probability of misclassification. So that is m ap that is naive base. Back to the notebook so just like how I imported k near k neighbors classifier up here for naive base I can go to sk learn. naive base and I can import Gaussian naive base. And here I'm going to say my naive base model is equal this is very similar to what we had above and I'm just going to say with this model where you are going to fit x train and y train. All right just like above. So this time I actually so I'm going to set that and exactly just like above I'm going to make my prediction so here I'm going to instead use my naive base model and of course I'm going to run the classification report again. So I'm actually just going to put these in the same cell but here we have the new y prediction and then y test is still our original test data set. So if I run this you'll see that okay let's go on here we get worse scores right our precision for all of them they look slightly worse and our you know for our precision our recall our f1 score they look slightly worse for all the different categories and our total accuracy I mean it's still 72% which is not too shabby but it's still 72% okay um which you know is not not accurate okay so let's move on to logistic regression here I've drawn a plot I have y so this is my label on one axis and then this is maybe one of my features so let's just say I only have one feature in this case text zero right well we see that you know I have a few of one class type down here and we know it's one class type because it's zero and then we have our other class type one up here okay so many of you guys are familiar with regression so let's start there if I were to draw a regression line through this it might look something like like this right well this doesn't seem to be a very good model like why would we use this specific line to predict why right it's it's it's iffy okay for example we might say okay well it seems like you know everything from here down words would be one class type and here upwards would be another class type but when you look at this you're just you visually can tell okay like that line doesn't make sense things are not those dots are not along that line and the reason is because we are doing classification not regression okay well first of all let's start here we know that this model if we just use this line it equals mx so whatever this let's just say it's x plus b which is the binary set right and m is the slope but when we use a linear regression is it actually why had no it's not right so when we're working with linear regression what we're actually estimating in our model is a probability what's a probability between zero and one that is class zero or class one so here let's rewrite this as p equals mx plus b okay well mx plus b that can range you know from negative infinity to infinity right for any for any value of x it goes from negative infinity to infinity but probability we know probably one of the rules of probability is that probability has to stay between zero and one so how do we fix this well maybe instead of just setting the probability equal to that we can set the odds equal to this so by that I mean okay let's you probability divided by one minus the probability okay so now becomes this ratio now this ratio is allowed to take on infinite values but there's still one issue here let me move this over the one issue here is that nx plus b that can still be negative right like if you know I have a negative slope if I have a negative b if I have some negative x isn't there I don't know but that can be that's allowed to be negative so how do we fix that we do that by actually taking the log of the odds okay so now I have the log of you know some probability divided by one minus the probability and now that is on a range of negative infinity to infinity which is good because the range of log should be negative infinity to infinity now how do I solve for p the probability well the first thing I can do is take you know I can remove the log by taking the net the e to the whatever is on both sides so that gives me the probability over the one minus the probability is now equal to e to the nx plus b okay so let's multiply that out so the probability is equal to 1 minus probability e to the mx plus b so p is equal to e to the mx plus b minus p times e to the mx plus b and now we have we can move like terms to one side so if I do p so basically I'm moving this over so I'm adding p so now p 1 plus e to the mx plus b is equal to e to the mx plus b and let me change this parentheses make a little bigger so now my probability can be e to the mx plus b divided by one plus e to the mx plus b okay well let me just rewrite this really quickly I want a numerator of one on top okay so what I'm going to do is I'm going to multiply this by negative mx plus b and then also the bottom by negative mx plus b and I'm a lot do that because this over this is one so now my probability is equal to one over 1 plus e to the negative mx plus b and now why do I be ready like that it because this is actually a form of a special function which is called the sigmoid function and for the sigmoid function it looks something like this so s of x sigmoid you know that that's some x is equal to 1 over 1 plus e to the negative x so essentially what I just did up here is rewrite this in some sigmoid function where the x value is actually mx plus b so maybe I all change this to y just to make that a bit more clear it doesn't matter what the variable name is but this is our sigmoid function and visually what our sigmoid function looks like is it goes from 0 so this here is 0 to 1 and it looks something like this curved s which I didn't draw it too well let me try that again it's a hard to draw something if I can draw this right like that okay so it goes in between 0 and 1 and you might notice that this 4 fits our shape up here oops let's draw a sharper but if it's our shape up there a lot better right all right so that is what we call logistic regression we're basically trying to fit our data to the sigmoid function okay and when we only have one data point so if we only have one feature x and that's what we call simple logistic regression but then if we have you know so that's only x 0 but then if we have x 0 x 1 all the way to x n we call this multiple logistic regression because there are multiple features that we're considering when we're building our model logistic regression so I'm going to put that here and again from sk learn this linear model we can import logistic regression all right and just like how we did we can repeat all of this so here instead of nb I'm going to call this log model or lg logistic regression I'm going to change this to logistic regression so I'm just going to use the default logistic regression but actually if you look here you see that you can use different penalties so right now we're using an l2 penalty but l2 is our quadratic formula okay so that means that for you know outliers it would really penalize that for all these other things you know you can toggle these different parameters and you might get slightly different results if I were building a production level the just regression model then I would want to go and I would want to figure out you know what are the best parameters have passed into here based on my validation data but for now we'll just we'll just use a sound of the box so again I'm going to fix the x train and the y train and I'm just going to predict again so I can just call this again instead of lg and b I'm going to use lg so here this is decent precision 65% recall 71 f168 or 82 total accuracy of 77 okay so it performs slightly better the night base but it's still not as good as k and n all right so the last model for classification that I wanted to talk about is something called support vector machines or SVMs for short so what exactly is an SVM model that I have two different features x0 and x1 on the axes and then I've told you if it's you know class zero or class one based on the blue and the red labels my goal is to find some sort of line between these two labels that best divides the data all right so this line is our SVM model so I call it a line here because in 2D it's a line but in 3D it would be a plane and then you can also have more and more dimensions so the proper term is actually I want to find the hyperplane that best differentiates these two classes let's see a few examples okay so first between these three lines say a b and c which one is the best divider of the data which one has you know all the data on one side or the other or at least if it doesn't which one divides it the most right like which one has the most defined boundary between the two different groups so this this question should be pretty straightforward it should be a right because a has a clear distinct line between where you know everything on this side of a is one label it's negative and everything on this side of a is the other label it's positive so what if I have a but then what if I had drawn my b like this and my c maybe like this sorry they're kind the labels are kind of close together but now which one is the best so I would argue that it's still a right and why is it still a because in these other two look at how close this is to that to these points right so if I had some new point that I wanted to estimate okay say I didn't have a or b so let's say we're just working with c let's say I have some new point that's right here or maybe a new point that's right there well it seems like just logically looking at this I mean without the boundary that would probably go under the positives right I mean it's pretty close to that other positive so one thing that we care about in SVM is something known as the margin okay so not only do we want to separate the two classes really well we also care about the boundary in between where the points in those classes and our data set are and the line that we're drawing so in a line like this the closest values to the line might be like here I'm trying to draw these perpendicular right and so this effectively if I switch over to these dotted lines if I can draw this right so these effectively are what's known as the margins okay so these both here these are our margins in our SVMs and our goal to maximize those margins so not only do we want the line that best separates the two different classes we want the line that has the largest margin and the data points that lie on the margin lines the data so basically these are the data points that's helping us to find our divider these are what we call support vectors hence the name support vector machines okay so the issue with SVM sometimes is that they're not so robust to outliers right so for example if I had one outlier like this up here that would totally change where I want my support vector to be even though that might be my only outlier okay so that's just something to keep in mind as you know when you're working with SVMs is it might not be the best model if there are outliers in your data set okay so another example of SVMs might be let's say that we have data like this I'm just going to use a one dimensional data set for this example let's say we have a data set that looks like this well our you know separators should be perpendicular to the line but it should be somewhere along the line so it could be anywhere like this you might argue okay well there's one here and then you could also just draw another one over here right and then maybe you can have two SVMs but that's not really how SVMs work but one thing that we can do is we can some sort of projection so I realized here that one thing I forgot to do was to label where zero was so let's just say zero is here now what I'm going to do is I'm going to say okay I'm going to have X and then I'm going to have X sorry X zero and X one so X zero is just going to be my original X but I'm going to make X one equal to let's say X squared so whatever is this squared right so now my negatives would be you know maybe somewhere here here just pretend that it's somewhere up here right and now my plus is might be something like that and I'm going to write out a space over here so I'm just going to draw these together you your imagination but once I draw it like this well it's a lot easier to apply a boundary right now our SVM could be maybe something like this this and now you see that we've divided our data set now it's separable where one class is this way and the other class is that way okay so that's known as SVMs I do highly suggest that you know any of these models that we just mentioned if you're interested in them do go more in depth mathematically into them like how do we how do we find this hyperplane right I'm not going to go over that in this specific course because you're just learning what an SVM is but it's a good idea to know oh okay this is the technique behind finding you know what exactly are the how do you define the hyperplane that we're going to use so anyways this transformation that we did down here this is known as the kernel trick so when we go from x to some coordinate x and then x squared what we're doing is we are applying a kernel so that's why it's called the kernel trick so SVM is actually really powerful and you'll see that here so from SK learn but SVM we are going to import SVC and SVC is our support vector classifier so with this so with our SVM model we are going to you know create SVC model and we are going to again fit this x frame I could have just got the invasive this I should have probably done that okay take a bit longer all right let's predict using our SVM model and here let's see if I can hover over this right so again you see a lot of these different parameters here that you can go back and change if you are creating a production level model okay but in this specific case we'll just use it out of the box again so if I make predictions you'll note that wow the accuracy actually jumps to 87% with the SVM and even with class 0 there's nothing less than you know 0.8 which is great and for class 1 I mean everything's that 0.9 which is higher than anything that we had seen to this point so so far we've gone over four different classification model we've done SVM's registered regression, naive bays and canon and these are just simple ways on how to implement them each of these they have different you know they have different hyper parameters that you can go and you can toggle and you can try to see if that helps later on or not but for the most part they perform they give us around 70 to 80% accuracy okay with SVM being the best now let's see if we can actually beat that using a neural net now the final type of model that I wanted to talk about is known as a neural net or neural network and neural nets look something like this so you have an input layer this is where all your features would go and they have all these arrows pointing to some sort of hidden layer and then all these arrows point to some sort of output layer so what is what does all of this mean each of these layers in here this is something known as a neuron okay so that's a neuron in a neural net these are all of our features that we're inputting into the neural net so that might be X0, X1 all the way through Xn right and these are the features that we talked about they might be you know the pregnancy the BMI the age etc now all of these get weighted by some value so they multiplied by some W number that applies to that one specific category that one specific feature so these who get multiplied and the sum of all of these goes into that neuron okay so basically I'm taking W0 times X0 and then I'm adding X1 times W1 and then I'm adding you know X2 times W2 etc all the way to Xn times Wn and that's getting input into the neuron now I'm also adding this bias term which just means okay I might want to shift this by a little bit so I might add five or I might add 0.1 or I might subtract a hundred I don't know but we're going to add this bias term and the output of all these things so the sum of this this this and this go into something known as an activation function okay and then after applying this activation function we get an output and this is what a neuron would look like now we'll network of them would look something like this so I kind of gloss over this activation function what exactly is that this is how a neural net looks like if we have all our inputs here and let's say all of these arrows represent some sort of addition right then what's going on is we're just adding a bunch of times right we're adding the some sort of weight times these input layer a bunch of times and then if we were to go back and factor that all out then this entire neural net is just a linear combination of these input layers which I don't know about you but that just seems kind of useless right because we could literally just write that out in a formula why would we need to set up this entire neural neural network we would so the activation function is introduced right so without an activation function this just becomes a linear model an activation function might look something like this and as you can tell these are not linear and the reason why we introduce these is so that our entire model doesn't collapse on itself and become a linear model so over here this is something known as a sigmoid function it runs between zero and one, tant runs between negative one all the way to one and this is real which anything less than zero is zero and then I think greater than zero is linear so with these activation functions every single output of a neuron is no longer just the linear combination of these it's some sort of altered linear state which means that the input into the next neuron is you know it doesn't it doesn't collapse on itself it doesn't become linear because we've introduced all these non-linearities so this is a training set the model the loss right and then we do this thing called training where we have to feed the loss back into the model and make certain adjustments the model to improve this predicted output let's talk a little bit about the training what exactly goes on during that step let's go back and take a look at our L2 loss function this is what our L2 loss function looks like it's a quadratic formula right well up here the error is really really really really large and our goal is to get some we're down here where the loss is decreased right because that means that our predicted value is closer to our true value so that means that we want to go this way okay and thanks to a lot of properties of math something that we can do is called gradient descent in order to follow this slope down this way this quadratic is it has different slopes with respect to some value okay so the loss with respect to some weight W0 versus W1 versus WN they might all be different right so some way that I kind of think about it is to what extent is this value contributing to our loss and we can actually figure that out through some calculus which we're not going to touch up on in this specific course but if you want to learn more about neural nets you should probably also learn some calculus and figure out what exactly back propagation is doing in order to actually calculate you know how much do we have the back step by so the thing is here you might notice that this follows this curve at all of these different points and the closer we get to the bottom the smaller this step becomes now stick with me here so my new value this is what we call weight update I'm going to take W0 and I'm going to set some new value for W0 and what I'm going to set for that is the old value of W0 plus some factor which I'll just call Alpha for now times whatever this arrow is so that's basically saying okay take our old W0 our old weight and just decrease it this way so I guess increase it in this direction right like take a step in this direction but this Alpha here is telling us okay don't don't take a huge step right just in case we're wrong take a small step take a small step and that direction see if we get any closer and for those of you who you know do want to look more into the mathematics of things the reason why I use a plus here is because this here is the negative gradient right if this were just if you were to use the actual gradient this should be a minus now this Alpha is something that we call the learning rate okay and that adjust how quickly we're taking steps and that might you know tell our that that will ultimately control how long it takes for our neural net to converge or sometimes if you said a too high it might even diverge but with all of these weights so here I have W0 W1 and then Wn we make the same update to all of them after we calculate the loss the gradient of the loss with respect to that weight so that's how back propagation works and that is everything that's going on here after we calculate the loss we're calculating gradients making adjustments in the model so we're setting all the all the weights to something adjusted slightly and then we're saying okay let's take the training set and run it through the model again and go through the loop all of right again so far machine learning we already have seen some libraries that we use right we've already seen as scalar but when we start going into neural networks this is kind of what we're trying to prove and it's not very fun to try to program this from scratch because not only will we probably have a lot of bugs but also probably not going to be fast enough right wouldn't be great if there are just some you know full-time professionals that are dedicated to solving this problem and they could literally just give us their code that's already running really fast well the answer is yes that exists and that's why we use tensorflow so tensorflow makes it really easy to define these models but we also have enough control over what exactly we're feeding into this model so for example this line here is basically saying okay let's create a sequential neural net so sequential is just you know what we've seen here it just goes one layer to the next and a denselyer means that all of them are interconnected so here this is interconnected with all of these nodes and this one's all of these and then this one gets connected to all of the next ones and so on so we're going to create 16 dense nodes with real activation functions and then we're going to create another layer of 16 dense nodes with real activation and then our outprelare is going to be just one node okay and that's how you it is to define something intensive flow so tensorflow is an open source library that helps you develop and train your ML models let's implement this for a neural net so we're using a neural net for classification now so our neural net model we are going to use tensorflow and I don't think I imported that up here so we are going to import that down here so I'm going to import tensorflow as TF and a trigger cool so my neural net model is going to be I'm going to use this so essentially this is saying layer all these things that I'm about to pass in so yeah layer them linear stack of layers layer the mesimodel and what that means nope not that so what that means I can pass in some sort of layer and I'm just going to use a dense layer oops dot dense and let's say we have 32 units okay I will also set the activation as real and at first we have the specified the input shape so here we have 10 comma all right so that's our first layer now our next layer I'm just going to have another a dense layer of 32 units all using relu and that's it so for the final layer this is just going to be my output layer it's going to just be one node and the activation is going to be sigmoid so if you recall from our logistic regression what happened there was when we had a sigmoid it looked something like this right so by creating a sigmoid activation on our last layer we're essentially projecting our predictions to be zero or one just like in logistic regression and that's going to help us you know we can just round two zero or one and classify that way so this is my neural net model and I'm going to compile this so intense with flow we have to compile it it's really cool because I can just literally pass in what type of optimizer I want and it'll do it so here if I go to the optimizers I'm actually going to use atom and you'll see that you know the learning rate is zero point zero zero one so I'm just going to use that default so zero point zero zero one and my loss is going to be binary cross entropy and the metrics that I'm also going to include on here so it it already will consider loss but I'm also going to tack on accuracy so we can actually see that in a plot later on all right so I'm going to run this and one thing that I'm going to also do is I'm going to define these plot definition so I'm actually copying pasting this I got these from tensorflow so if you go on to some tensorflow tutorial they actually have these this like defined and that's exactly what I'm doing here so I'm actually going to move this cell up run that so we're basically plotting the loss over all the different epochs epochs means like training cycles and we're going to plot the accuracy overall the epochs all right so we have our model and now all that's left is let's train it okay so I'm going to say history so tensorflow is great because it keeps track of the history of the training which is why we can go and plot it later on now I'm going to set that equal to this neural net model and fit that with x train y train I'm going to make the number of epochs equal to let's say let's just use a hundred for now and the batch size I'm going to set equal to let's say 32 all right and the validation split so what the validation split does if it's down here somewhere okay so yeah this validation split is just the fraction the training data to be used as validation data so essentially every single epoch what's going on is tensorflow saying leave certain if this is 0.2 then leave 20% out and we're going to test how the model performs on that 20% that we've left out okay so it's basically like our validation data set but tensorflow does it on our training data set during the training so we have now a measure outside of just our validation data set to see you know what's going on so validation split I'm going to make that 0.2 and we can run this so if I run that all right and I'm actually going to set verbose equal to 0 which means okay don't print anything because pretty something for a hundred epochs might get kind of annoying so I'm just going to let it run let it train and then we'll see what happens cool so it finished train and now what I can do is because you know I've already defined these two functions I can go ahead and I can plot the loss oops plot loss of that history and I can also plot the accuracy throughout the training so this is a little bit ish what we're looking for we definitely are looking for a steadily decreasing loss and an increasing accuracy so here we do see that you know our validation accuracy improves from around 0.77 or something all the way up to somewhere around 0.881 and our loss is decreasing so this is good it is expected that the validation loss and accuracy is performing worse than the training loss or accuracy and that's because our model is training on that data so it's adapting to that data whereas validation stuff is you know stuff that it hasn't seen yet so so that's why so in machine learning as we saw above we could change a bunch of the parameters right like I could change this is 64 so now it'd be a row of 64 nodes and then 32 and then 1 so I can change some of these parameters and a lot of machine learning is trying to find hey what do we set these hyper parameters to so what I'm actually going to do is I'm going to rewrite this so that we can do something what's known as a grid search so we can search through an entire space of hey what happens if you know we have 64 nodes and 64 nodes or 16 nodes and 16 nodes and so on and then on top of all that we can you know we can change this learning rate we can change how many epochs we can change you know the batch size all these things might affect our training and just for a kicks I'm also going to add what's known as a dropout layer in here and what dropout is doing is saying hey randomly choose with at this rate certain nodes and don't train them in you know a certain iteration so this helps prevent overfitting okay so I'm actually going to define this as a function called trade model we're in a passing x train y train the number of nodes the dropout you know the probability that we just talked about learning rate so I'm actually can say LR batch size and we can also pass the number of epochs right I mentioned that as a parameter so in dent this so it goes under here and with these two I'm going to set this equal to number of nodes and now with the two dropout layers I'm going to set out pro so now you know the probability of turning off a node during the training is equal to dropout pro and I'm going to keep the output layer the same now I'm compiling it but this here is now going to be my learning rate and I still want binary cross entropy and accuracy we are actually going to train our model inside of this function but here we can do the epochs equal epochs and this is equal to whatever you know we're passing in x train y train belong right here okay so those are getting passed in as well and finally at the end I'm going to return this model and the history of that model okay so now what I'll do is let's just go through all of these so let's say let's keep the epochs out 100 and now what I can do is I can say hey for a number of nodes and let's say let's do 16 32 and 64 to see what happens for the different dropout probabilities and I mean zero being nothing let's use 0.2 also to see what happens you know for the learning rate in 0.005 0.001 and you know maybe we want to throw on 0.1 in there as well and then for the batch size let's do 16 32 64 as well actually and let's also throw on 128 actually let's get rid of 16 sorry so 128 in there that should be 0.1 I'm going to record the model in history using this train model here so we're going to do x train y train the number of nodes is going to be you know the number of nodes that we've defined here drop out out out lr batch size and epochs okay and then now we have both the model and the history and what I'm going to do is again I want to plot the loss with the history and most of them plot the accuracy probably should have done them side by side that probably would have been easier okay so what I'm going to do is split up split this up and that will be subplots so now this is just saying okay I want 1 row and 2 columns of that row for my plots okay so I'm going to plot on my axis 1 the loss I don't actually know this is going to work here we don't care about the grid yeah let's keep the grid and then now on my other so now on here I'm going to plot all the accuracy on the second plot I might have to debug this a bit we should be able to get rid of that if we run this we already have history saved as a variable in here so if I just run it on this okay it has no attribute x label I think it's because it's like set x label or something okay yeah so it's set instead of just x label y label so let's see if that works alright cool and let's actually make this a bit larger okay so we can actually change the size and I'm going to set let's do what happens if I set that to oh that's not the way I wanted it um okay so that looks reasonable and that's just going to do my plot history functions so now I can plot them side by side here I'm going to plot the history and what I'm actually going to do is I so here first I'm going to print out all these parameters so I'm going to print out is the F string to print out all of this stuff so here I'm putting out how many nodes the dropout probability the learning rate and we already know how many times I'm not going to bother with that so once we plot this let's actually also figure out what the validation losses are validation set that we have that we created all the way back up here alright so remember we created three datasets let's call our model and evaluate what the validation data with the validation data sets loss would be and I actually want to record let's say I want to record whatever model has the least validation loss so first I'm going to initialize that to infinity so that you know any model will beat that score so if I do float infinity that will set that to infinity and maybe I'll keep track of the parameters I'll probably it doesn't really matter I'm just going to keep track of the model and I'm going to set that to none so now down here if the validation loss is ever less than least validation loss then I am going to simply come down here and say hey this validation or this least validation loss is now equal to the validation loss and the least loss model is whatever this model is that just earned that validation loss okay so we are actually just going to let this run for a while and then we're going to get our least loss model after that so let's just run alright and now we wait alright so we have finally finished training and you'll notice that okay down here the loss actually gets to like 0.29 the accuracy is around 88% which is pretty good so you might be wondering okay why is this accuracy in this like these are both the validation so this accuracy here is on the validation data set that we've defined at the beginning right and this one here this is actually taking 20% of our test our training set every time during the training and saying okay how much of it do I get right now you know after this one step where I didn't train with any of that so they're slightly different and actually I realize later on that I probably you know probably what I should have done is over here when we were defining the model fit instead of the validation split you can define the validation data and you can pass in the validation data I don't know if this is the proper syntax but that's probably what I should have done but instead you know we'll just stick with what we have here so you'll see at the end you know with the 64 nodes it seems like this is our best performance 64 nodes with a dropout of 0.2 alerting rate of 0.001 and a back size of 64 and it does seem like yes the validation you know the fake validation but the validation loss is decreasing and then the accuracy is increasing which is a good sign okay so finally what I'm going to do is I'm actually just going to predict so I'm going to take this model which we've called our least lost model I'm going to take this model and I'm going to predict x test on that and you'll see that it gives me some values that are really close to 0 and some that are really close to 1 and that's because we have a sigmoid output so if I do this and what I can do is I can cast them so I'm going to say anything that's greater than 0.5 set that to 1 so if I actually I think what happens if I do this okay so I have to cast that as type and so now you'll see that it's 1's and 0's and I'm actually going to transform this into a column as well so here I'm going to oops I didn't mean to do that okay no I wanted to just reshape it to that so now it's 1 dimensional okay and using that we can actually just rerun the classification report based on this neural net output and you'll see that okay the the f ones or the accuracy gives us 87% so it seems like what happened here is the precision on class 0 so the hat runs has increased a bit but the recall decreased but the f ones were still at a good 0.81 and for the other class it looked like the precision decreased a bit the recall increased for an overall f1 score that's also been increased I think I interpreted that properly I mean we went through all this work and we got a model that performs actually very very similarly to the SVM model that we had earlier and the whole point of this exercise was to demonstrate okay these are how you can define your models but it's also to say hey maybe you know neural nets are very very powerful as you can tell but sometimes you know an SVM or some other model might actually be more appropriate but in this case I guess it didn't really matter which one we use at the end and 87% accuracy score is still pretty good so yeah let's now move on to regression we just saw a bunch of different classification models now let's shift gears into regression the other type of supervised learning if we look at this plot over here we see a bunch of scattered data points and here we have our X value for those data points and then we have the corresponding Y value which is now our label and when we look at this plot well our goal and regression is to find the line of best fit that best models this data essentially we're trying to let's say we're given some new value of X that we don't have in our sample we're trying to say okay what would my prediction for Y B for that given X value so that you know might be somewhere around there I don't know but remember in regression that you know given certain features we're trying to predict some continuous numerical value for Y in linear regression we want to take our data and fit a linear model to the data so in this case our linear model might look something along the lines of here right so this here would be considered as maybe our line of best fit and this line is modeled by the equation I'm going to write it down here Y equals B0 plus B1X now B0 just means it's this Y and our sub-sofics send this Y down here this value here's B0 and then B1 defines the slope of this line okay all right so that's the that's the formula for linear regression and how exactly do we come up with that formula what are we trying to do with this linear regression you know we could just eyeball where's the line B but humans are not very good at eyeballing certain things like that I mean we can get close but a computer is better I give me a precise value for B0 and B1 well let's introduce the concept of something known as a residual okay so residual you might also hear this being called the error and what that means is let's take some data point in our data set and we're going to evaluate how far off is our prediction from a data point that we already have so this here is our Y let's say this is 1 2 3 4 5 6 7 8 so this is Y let's call it you'll see that I use this Y I in order to represent hey just one of these points okay so this here is Y and this here would be the prediction in oops this here would be the prediction per Y 8 which I've labeled with this hat okay if it has a hat on it that means hey this is what this is in my guess this is my prediction for you know this specific value of x okay now the residual would be this distance here between Y 8 and Y hat 8 so Y 8 minus Y hat 8 all right because that would give us this here and I'm just going to take the absolute value of this because what if it's below the line right then you would get a negative value but distance can't be negative so we're just going to put a little hat or we're going to put a little absolute value around this quantity and that gives us the residual or the error so let me rewrite that and you know to generalize to all the points I'm going to say the residual can be calculated as Y I minus Y hat of I okay so this just means the distance between some given point and its prediction it's corresponding prediction on the line so now with this residual this line of best fit is generally trying to decrease these residuals as much as possible so now that we have some value for the error our line of best fit is trying to decrease the error as much as possible for all of the different data points and that might mean you know minimizing the sum of all the residuals so this here this is the sum symbol and if I just stick the residual calculation in there it looks something like that right and I'm just going to say okay for all of the eyes and our data set so for all the different points we're going to sum up all the residuals and I'm going to try to decrease that with my line of best fit so I'm going to find the B0 and B1 which gives me the lowest value of this okay now in other you know sometimes in different circumstances we might attach a squared to that so we're trying to decrease the sum of the squared residuals and what that does is it just you know it adds a higher penalty for how far off we are from you know points that are further off so that is linear regression we're trying to find this equation some line of best fit that will help us decrease this measure of error with respect to all the data points that we have in our data set and try to come up with the best prediction for all of them this is known as simple linear regression and basically that means you know our equation looks something like this now there's also multiple linear regression which just means that hey if we have more than one value for x so like think of our feature vector we have multiple values in our x vector then our predictor might look something more like this actually I'm just going to say et cetera plus bnx and so now I'm coming up with some coefficient for all of the different x values that I have in my vector now you guys might have noticed that I have some assumptions over here and you might be asking what you highly what in the world through these assumptions mean so let's go over them the first one is linearity and what that means is let's say I have a data set okay linearity just means okay my does my data follow a linear pattern does y increase as x increases or does y decrease as x increases does so if y increases or decreases at a constant rate as x increases then you're probably looking at something linear so what's the example of a nonlinear data set let's say I had data that might look something like that okay so now I'm just visually judging this you might say okay it seems like the line of best fit might actually be some curve like this right and in this case we don't satisfy that linearity assumption anymore so with linearity we basically just want our data set to follow some sort of linear trajectory and independence our second assumption just means this point over here it should have no influence on this point over here or this point over here or this point over here so in other words all the points all the samples in our data set should be independent okay they should not rely on one another they should not affect one another okay now normally and had a almost getasticity those are concepts which use this residual okay so if I have a plot that looks something like this and my line of best fit is somewhere here maybe it's something like that in order to look at these normality and how much capacity assumptions let's look at the residual plot okay and what that means is I'm going to keep my same x axis but instead of plotting now where they are relative to this y I'm going to plot these errors so now I'm going to plot y minus y hat like this okay and now you know this one is slightly positive so might be here this one now here's negative it might be here so our residual plot it's literally just a plot of how you know the values are distributed around our line of best fit so it looks like it might you know look something like this okay so this might be our residual plot and what normality means so our assumptions are normality and homo skidasticity skidasticity skidasticity I might have put your that spell you I don't really know but what normality is saying is saying okay these residuals should be normally distributed okay around this line of best fit it should follow a normal distribution and now what homo skidasticity says okay our variance of these points should remain constant throughout so this spread here should be approximately the same as this spread over here now what's an example of where you know homo skidasticity is not held well let's say that our original plot actually looks something like this okay so now if we look at the residuals for that it might look something like that and now if you we look at this spread of the points it decreases right so now the spread is not constant which means that homo skids that's homo skidasticity this assumption would not be fulfilled and it might not be appropriate to use linear regression so that's just linear regression basically we have a bunch of data points we want to predict some y value for those and we're trying to come up with this line of best fit that best describes hey given some value x what would be my best guess of what y is so let's move on to how do we evaluate a linear regression model so the first measure that I'm going to talk about is known as mean absolute error or m a e for short okay and mean absolute error is basically saying all right let's take all the errors so all these residuals that we talked about let's sum up the distance for all of them and then take the average and then that can describe you know how far off are we so the mathematical formula for that would be okay let's take all the residuals all right so this is the distance actually let me redraw a plot down here so suppose I have a data set look like this and here are all of my data points right and now let's say my line look something like that so my mean absolute error would be summing up all of these values this was a mistake so summing up all of these and then dividing by how many data points I have so what would be all the residuals it would be y i right so every single point minus y hat i so the prediction for that on here and then we're going to sum over all of the different i's in our data set right so i and then we divide by the number of points we have so actually I'm going to rewrite this make it a little clear so i is equal to whatever the first data point is all the way through the end to data point and then we divide it by n which is how many points there are okay so this is our measure of m a and this is basically telling us okay in on average this is the distance between our predicted value and the actual value in our training set okay and m a is good because it allows us to you know when we get this value here we can literally directly compare it to whatever units the y value is in so let's say y is we're talking you know the prediction of the price of a house right in dollars once we have once we calculate the m a we can literally say oh the average you know price the average how much we're off by is literally this many dollars okay so that's the mean absolute error an evaluation technique that's also closely related to that is called the mean squared error and this is m s e for short okay now if i take this plot again and i duplicate it and move it down here well the just of mean squared error is kind of same but instead of the absolute value we're going to square so now the m s e is something along the lines of okay let's sum up something right so we're going to sum up all of our errors so now i'm going to do y i minus y hat i but instead of absolute value may be on i'm going to square them all and then i'm going to divide by n in order to find the mean so basically now i'm taking all of these different values and i'm squaring them first before i add them to one another and then i divide by n and the reason why we like using mean squared error is that it helps us punish large errors in the prediction and later on m s e might be important because of differentiability right so a quadratic equation is differentiable you know if you're familiar with calculus a quadratic equation is different differentiable whereas the absolute value function is not totally differentiable everywhere but if you don't understand that don't worry about it you won't really need it right now and now one downside of mean squared error is that once i calculate the mean squared error over here and i go back over to y and i want to compare the values well it gets a little bit trickier to do that because now my mean squared error is in terms of y squared right it's this is now squared so instead of just dollars how you know how many dollars off am i i'm talking how many dollars squared off am i and that you know to humans it doesn't really make that much sense which is why we have created something known as the root mean square error and i'm just going to copy this diagram over here because it's very very similar to mean squared error except now we take a big squared root okay so this is our messy and we take the square root of that mean squared error and so now the term in which you know we're defining our error is now in terms of that dollar sign symbol again so that's a pro of root mean squared error is that now we can say okay our error according to this metric is this many dollar signs off from our predictor okay so it's in the same unit which is one of the pros of root mean squared error and now finally there is the coefficient of determination or r squared and this is the formula for r squared so r squared is equal to 1 minus rss over tss okay so what does that mean basically rss stands for the sum of the squared residuals so maybe it should be SSR instead but rss sum of the squared residuals and this is equal to if i take the sum of all the values and i take y i minus y hat i and square that that is my rss all right it's a sum of the squared residuals now tss let me actually use the different color for that so tss is the total sum of squares and what that means is that instead of being with respect to this prediction we are instead going to take each y value and just subtract the mean of all the y values and square that okay so if i drew this out and if this were my actually let's use a different color let's use green if this were my predictor so rss is giving me this measure here right it's giving me some estimate of how far off we are from our regressor that we predicted actually i'm going to use red for that well tss on the other hand is saying okay how far off are these values from the mean so if we literally didn't do any calculations for the line of estimate if we just took all the y values and average all of them and said hey this is the average value for every single x value i'm just going to predict that average value instead then it's asking okay how far off are all these points from that line okay and remember that this square means that we're punishing larger errors right so even if they look somewhat close in terms of distance the further a few data points are then the further the larger our total sum of squares is going to be sorry that was my dog so total sum of squares is taking all of these values and saying okay what is the sum of squares if i didn't do any regressor and i literally just calculated the average of all the y values in my data set and for every single x value i'm just going to predict that average which means that okay like that means that maybe y and x are associated with each other at all like the best thing that i can do for any new x value just predict hey this is the average of my data set and this total sum of squares is saying okay well with respect to that average what is our error right so up here this sum of the square residuals this is telling us what is our what what is our error with respect to this line and best fit while our total sum of squares saying what is the error with respect to you know just the average y value and if our line of best fit is a better fit then this total sum of squares that means that you know this numerator that means that this numerator is going to be smaller than this denominator right and if our errors in our line of best fit are much smaller then that means that this ratio of the rss over tss is going to be very small which means that r squared is going to go towards one and now when r squared is towards one that means that that's usually a sign that we have a good predictor it's one of the signs not the only one so over here i also have you know that there's this adjusted r squared and what that does it just adjust for the number of terms so x1 x2 x3 etc it adjusts for how many x returns we add because usually when we you know add an extra term the r squared value will increase because that'll help us predict y some more but the value for the adjusted r squared increases the new term actually improves this model fit more than expected you know by chance so that's what adjusted r squared is i'm not you know it's out of the scope of this one specific course and now that's linear regression basically i've covered the concept of residuals or errors and you know how do we use that in order to find the line of best fit and you know our computer can do all the calculations for us which is nice but behind the scenes it's trying to minimize that error right and then we've gone through all the different ways of actually evaluating a linear regression model and the pros and cons of each one so now let's look at an example so we're still on supervised learning but now we're just going to talk about regression so what happens when you don't just want to predict you know type one two three what happens if you actually want to predict a certain value so again I'm on the UCI machine learning repository and here I found this data set about bike sharing in sole uh South Korea so this data set is predicting rental bike count and here it's the count of bikes rented at each hour so what we're going to do again you're going to go into the data folder and you're going to download this CSV file and we're going to move over to Colab again and here I'm going to name this FCC uh bikes and regression I don't remember what I called the last one but yeah FCC bikes regression now I'm going to import a bunch of the same things that I did earlier and you know I'm going to also continue to import the over sampler and the standard scalar and then I'm actually also just going to let you guys know that I have a few more things I want to import so this is a library that lets us copy things Cborn is a wrapper over a matte plot lib so it also allows us to plot certain things and then just letting you know that we're also going to be using tensorflow okay so one more thing that we're also going to be using we're going to use the SK learn linear model library actually let me make my screen a little bit bigger so yeah awesome run this and that'll import all the things that we need so again I'm just going to you know give some credit to where we got this data set so let me copy and paste this UCI thing and I will also give credit to this here okay cool all right cool so this is our data set and again it tells us all the different attributes that we have right here so I'm actually going to go ahead and paste this in here feel free to copy and paste this if you want me to read it out loud so you can type it it's by count our temp humidity wind visibility dew point temp radiation rain snow and functional whatever that means okay so I'm going to come over here and import my data by dragging and dropping all right now one thing that you guys might actually need to do is you might actually have to open up the CSV because there were at first a few like forbidding characters in mine at least so you might have to get rid of like I think there was a degree here but my computer wasn't recognizing it so I got rid of that so you might have to go through and get rid of some of those labels that are incorrect um I'm gonna do this okay but after we've done that we've imported in here I'm going to create a data a data frame from that so all right so now what I can do is I can read that CSV file and I can get the data into here so so like data dot uh CSV okay so now if I call data dot head you'll see that I have all the various labels right and then I have the data in there so I'm going to from here I'm actually going to get rid of some of these columns that you know I don't really care about so here I'm going to when I when I type this in I'm going to drop maybe the date whether or not it's a holiday and the various seasons so I'm just not gonna care about these things access equals one means drop it from the columns so now you'll see that okay we still have I mean I guess you don't really notice it but if I set the data frames columns equal to data set calls and I looked at you know the first five things then you'll see that this is now our data set it's a lot easier to read so another thing is I'm actually going to yeah functional and we're going to create this so remember that our computers are not very good at language we want it to be in zeros and ones so here I will convert that well if this is equal to yes then that that gets mapped as one so then set type integer all right great cool so the thing is right now these by counts are for whatever hour so to make this example simpler I'm just going to index on an hour and I'm just say okay we're only going to use that specific hour so here let's say so this data frame is only going to be data frame where the hour let's say it equals 12 okay so it's noon all right so now you'll see that all the hours are equal to 12 and I'm actually going to now drop that column our axis equals one all right so if we run this cell okay so now we got rid of the hour in here and we just have the bike count the temperature humidity when visibility and yada yada yada all right so what I want to do is I'm going to actually plot all of these so for I and all the columns so the range length of whatever its data frame is and all the columns because I don't have bike count as actually it's my first thing so what I'm going to do is say for a label and data frame columns everything after the first thing so that would give me the temperature and onward so these are all my features right I'm going to just scatter so I want to see how that label, how that specific data, how that affects the bike count so I'm going to plot the bike count on the y axis and I'm going to plot you know whatever this specific label is on the x axis and I'm going to title this whatever label is and you know make my y label the bike count at noon and the x label has just the label okay now I guess we don't even need the legend so just show that plot all right so it seems like functional is not really uh doesn't really give us any utility so then snow rain seems like this radiation you know is fairly linear do point temperature visibility wind doesn't really seem like it does much humidity kind of maybe like an inverse relationship but the temperature definitely looks like there's a relationship between that and the number of bikes right so what I'm actually going to do is I'm going to drop some of the ones that don't don't seem like they really matter so maybe wind you know visibility yeah so I'm going to get rid of wind visibility and functional so you know data frame and I'm going to drop wind visibility and functional all right and the axis again is a column so that's one so if I look at my data set now I have just the temperature the humidity the dew point temperature radiation rain and snow so again what I want to do is I want to split this into my training my validation and my test data set just as we talked before here we can use the exact same thing that we just did and we can say numpy dot split and sample you know that the whole sample and then create our splits of the data frame and we're going to do that the now set this to eight okay so I don't really care about you know the the full grid the full array so I'm just going to use an underscore for that variable but I will get my training X and Y's and actually I don't have a function for getting the X and Y's so here I'm going to write a function to find get X Y and I'm going to pass in the data frame and I'm actually going to pass in what the name of the Y label is and what the X what specific X labels I want to look at so here if that's none then I'm just not like I'm only going to I'm going to get everything from the data set that's not the Y like so here I'm actually going to make first a deep copy of my data frame and that basically means I'm just copying everything over if if like X labels is none so if not X labels then all I'm going to do is say all right X is going to be whatever the data frame is and I'm just going to take all the columns so see for see in data frame dot columns if C does not equal the Y label all right and I'm going to get the values from that but if there is the X labels well okay so in order to index only one thing so like let's say I pass an only one thing in here then my data frame is so let me make a case for that so if the length of X labels is equal to one then what I'm going to do is just say that this is going to be X labels and at that just that label values and I actually need to reshape to make this 2D so I'm going to pass a negative one comma one there now otherwise if I have like a list of specific X labels that I want to use then I'm actually just going to say X is equal to data frame of those X labels dot values and that should suffice all right so now that's just me extracting X and in order to get my Y I'm going to do Y will stay to frame and then pass in the Y label and that's the very end I'm going to say data equals NP dot H stack so I'm stacking them horizontally one X to each other and I'll take X and Y and return that but this needs to be values and I'm actually going to reshape this to make it 2D as well so that we can do this H stack and I will turn data X Y so now I should be able to say okay get X Y and take that data frame and the Y label so my Y label is by count and actually so for the X label I'm actually going to let's just do like one dimension right now and earlier I got rid of the plots but we had seen that maybe you know the temperature dimension does really well and we might be able to use that to predict Y so I'm going to label this also that you know it's just using the temperature and I am also going to do this again for of this should be frame and this should be validation and this should be test because oh that's vowel right but here it should be vowel and this should be test all right so we run this and now we have our training validation and test data sets for just the temperature so if I look at X train temp it's literally just the temperature okay and I'm doing this first to show you simple linear regression all right so right now I can create a regressor so I can say the temp regressor here and then I'm going to you know make a linear regression model and just like before I can simply fix fit my X train temp Y train temp in order to train train this linear regression model all right and then I can also I can print this regressor is coefficients and the intercept so if I do that okay this is the coefficient for whatever the temperature is and then the the X intercept okay or the Y intercept sorry all right and I can you know score so I can get the the R squared score so I can score X test and Y test temp all right so it's an R squared of around 0.38 which is better than zero which would mean hey there's absolutely no association but it's also not you know like a good depends on the context but you know the higher that number it means the higher that the two variables would be correlated right which here it's all right it just means there's maybe some association between the two but the reason why I want to do this one D was to show you you know if we plotted this this is what it would look like so if I create a scatter plot and let's take the training um so this is our data and then let's make it blue and then if I also plotted so something that I can do is say you know the X range I'm going to plot it is LIM space and this goes from negative to 20 to 40 this piece of data so I'm going to just say let's take 100 things from there so I'm going to plot X and I'm going to take this temper this like regressor and predict X with that okay and this label I'm going to label that um the fit and this color let's make this red and let's actually set the line with so I can I can change how thick that value is okay now at the very end let's create a legend and let's all right let's also create you know title all these things that matter in some sense so here let's just say um this would be the bikes versus the temperature right and the y label would be number of bikes and the X label would be the temperature so I actually think that this might cause an error yeah so it's expecting a 2D array so we actually have to reshape this okay there we go so I just had to make this an array and then reshape it so it was 2D now we see all right this increases but again remember those assumptions that we had about linear regression like this I don't really know if this fits those assumptions right I just wanted to show you guys though that like all right this is what a line of best fit through this data would look like okay now we can do multiple linear regression right so I'm going to go ahead and do that as well now if I take my data set and instead of the labels it's actually what's my current data set right now all right so let's just use all of these except for the bike count right so I'm going to just say for the X labels let's just take the data frames columns and just remove the bike count so does that work so if this part should be a fix labels is none and then this should work now oops sorry okay so I have oh but this here because it's not just the temperature anymore we should actually do this let's say all right so I'm just going to quickly rerun this piece here so that we have our temperature only data set and now we have our all data set okay and this regressor I can do the same thing so I can do the all regressor and I'm going to make this the linear regression and I'm going to fit this to X train all and Y train all okay all right so let's go ahead and also score this regressor and let's see how the R square performs now so if I test this on the test data set what happens all right so our R square seems to improve it went from point four to point five to which is a good sign okay and I can't necessarily plot you know every single dimension but this just this is just to say okay this has this is improved right all right so one cool thing that you can do with tensor flows you can actually do regression but with the neural net so here I'm going to we already have our training data for just the temperature and just you know for all the different columns so I'm not going to bother with splitting up the data again I'm just going to go ahead and start building the model so in this linear regression model typically you know it does help if we normalize it so that's very easy to do with tensor flow I can just create some normalize there layer so I'm going to do tensor flow carous layers and get the normalization layer and the input shape for that will just be one because let's just do it again on just the temperature and the axis I will make none now for this temp normalizer and I should have had an equal sign there I'm going to adapt this to x train temp and reshape this to just a single vector so that should work great now with this model so temp neural net model what I can do is I can do you know dot carous let's stick bunchle and I'm going to pass in this normalizer layer and then I'm going to say hey just give me one single dense layer with one single unit and what that's doing is saying all right well one single node just means that it's linear and if you don't add any sort of activation function to it the output is also linear so here I'm going to have tensor flow carous layers dot dense and I'm just going to have one unit and that's going to be my model okay so with this model let's compile and for our optimizer let's use let's use the atom again and we have to pass in the learning rate so learning rate and our learning rate let's do 0.01 and now the loss we actually let's get this one 0.01 and the loss I'm going to do means squared error okay so we run that we've compiled it okay great and just like before we can call a history and I'm going to fit this model so here if I call fit I'm just fit it and I'm going to take the X train with the temperature but reshape it Y train for the temperature and I'm going to set verbose equal to 0 so that it doesn't you know display stuff I'm actually going to set epochs equal to 1,000 and the validation data should be let's pass in the validation data set here as a tuple and I know it's about that wrong so let's just run this and up here I've copied pasted the plot loss from our previous but changed the viable to MSC because now we're dealing with mean squared error and I'm going to plot the loss of this history after it's done so let's just wait for this to finish training and then to plot okay so this actually looks pretty good we see that the values are converging so now what I can do is I'm going to go back up and take this plot and we are going to just run that plot again so here instead of this temperature regress where I'm going to use the neural net regressor the neural net model and if I run that I can see that you know this also gives me a linear regressor you'll notice that this this fit is not entirely the same as the one up here and that's due to the training process of you know of this neural net so just two different ways to try and try to find the best linear regressor okay but here we're using back propagation to train a neural net node whereas in the other one they probably are not doing that okay they're probably just trying to actually compute the line of us fit so okay given this while we can repeat the exact same exercise with our with our multiple linear regressions okay but I'm actually going to skip that part I will leave that as an exercise to the viewer okay so now what would happen if we use a neural net a real neural net instead of just you know one single node in order to predict this so let's start on that code we already have our normalizer so I'm actually going to take the same set up here but instead of you know this one dense layer I'm going to set this equal to 32 units and for my activation I'm going to use relub and now let's duplicate that and for the final output I just want one answer so I just want one cell and this activation is also going to be relub because I can't ever have less than zero bike so I'm going to set that as relub I'm just going to name this the neural net model okay and at the bottom I'm going to have this neural net model I'm going to have this neural net model I'm going to compile and I will actually use the same compiler here but instead of instead of alerting or is your 0.01 I'll use 0.001 okay and I'm going to train this here so the history is this neural net model and I'm going to fit that against x train temp y train temp and valid validation data I'm going to set this again equal to x val temp and y val temp now for the verbose I'm going to take with zero u-pox let's do a hundred and here for the batch size actually let's just not do a batch size right now let's just try let's see what happens here and again we can plot the loss of this history after it's done training so let's just run this and that's not what we're supposed to get so what is going on here is sequential we have our temperature normalizer which I'm wondering now if we have to re do that okay so we do see this decline it's an interesting curve but we do we do see it eventually so this is our loss which all right if it's decreasing that's a good sign and actually what's interesting is let's just let's plot this model again so here instead I'm going to set this up and you'll see that we actually have this curve that looks something like this so actually what if I got rid of this activation let's train this again and see what happens all right so even even when I got rid of that re-lude at the end it kind of knows hey you know if it's not the best model if we had maybe one more layer in here there's these are just things that you have to play around with when you're you know working with machine learning it's like you don't really know what the best model is going to be for example this also is not brilliant but I guess it's okay so my point is though that with a neural net I mean this is not brilliant but also there's like no data down here right so it's kind of hard for our model to predict in fact we probably should have started the prediction somewhere around here my point though is that with this neural net model you can see that this is no longer a linear predictor but yet we still get an estimate of the value right and we can repeat this exact same exercise with the multiple inputs so here if I now pass in all of the data so this is my all normalizer and I should just be able to pass in that so let's move this to the next cell here I'm going to pass in my all normalizer and let's compile it yeah those parameters look good great so here with the history when we're trying to fit this model instead of temp we're going to use our larger data set with all the features and let's just train that and of course we want to plot the loss okay so that's what our loss looks like um so an interesting curve but it's decreasing so before we saw that our squared score was around point five two well we don't really have that with a neural net anymore but one thing that we can measure is hey what is the mean squared error right so if I come down here um and I compare the two mean squared errors so so I can predict x test all right so these are my predictions using that linear regressor will linear multiple linear regressor so these are my my predictions near regression okay I'm actually going to do that at the bottom so let me just copy and paste that cell and bring it down here so now I'm going to calculate the mean squared error for both the linear regressor and the neural net okay so this is my linear and this is my neural net so if I do my neural net model and I predict x test all I get my two you know different y predictions and um I can calculate the mean squared right so if I want to get the mean squared error and I have y prediction and y real I can do nampai dot square and then I would need the y prediction minus you know the real so this this is basically everything um and this should be a vector so if I just take this entire thing and take the mean of that that should give me the MSC so let's just try that out and the y real is y test all right so that's my mean squared error for the linear regressor and this is my mean squared error for the neural net so that's interesting I will debug this live I guess so my guess is that it's probably coming from this normalization layer um because this input shape is probably just six okay so that works now and the reason why is because like my inputs are only for every vector it's only a one dimensional vector of length six so I should have just had six comma which is a two-pole of six from the start or it's a it's a two-pole containing one element which is six okay so it's actually interesting that my neural net results seem like they they have a larger mean squared error than my linear regressor um one thing that we can look at is we can actually plot the real versus you know the the actual results versus what the predictions are so if I say some axis and I use PLT dot axes and make these equal then I can scatter the the y you know the test so what the actual values are on the x axis and then what the prediction are on the x axis okay and I can label this as the linear regression predictions okay so then let me just label my axis so the x axis I'm going to say this is a true values the y axis is going to be my linear regression predictions or actually let's plot let's just make this predictions and then at the end I'm going to plot oh let's set some limits uh because I think that's like approximately the back number of bikes so I'm going to set my x limit to this and my y limit to this so here I'm going to pass that in here too and all right this is what we actually get for our linear regressor you see that actually they align quite well I mean to some extent so 2000's probably too much 2500 I mean looks like maybe like 1800 would be enough here for our limits and I'm actually going to label something else the neural net predictions let's add a legend so you can see that our neural net for the larger values it seems like it's a little bit more spread out and it seems like we tend to underestimate a little bit down here in this area okay and for some reason these are way off as well but yeah so we've basically used a linear regressor and a neural net um honestly there are sometimes where a neural net is more appropriate and a linear regressor is more appropriate I think that it just comes with time and trying to figure out you know and just literally seeing like hey what works better like here a linear multiple linear regressor might actually work better than a neural net but for example with the one-dimensional case a linear regressor would never be able to see this curve okay I mean I'm not saying this is a great model either but I'm just saying like hey you know sometimes it might be more appropriate to use something that's not linear so yeah I will leave regression at that okay so we just talked about supervised learning and in supervised learning we have data we have some a bunch of features and for a bunch of different samples but each of those samples has some sort of label on it whether that's a number a category a class etc right we were able to use that label in order to try to predict new labels of other points that we haven't seen yet well now let's move on to unsupervised learning so with unsupervised learning we have a bunch of unlabeled data and what can we do with that you know can we learn anything from this data so the first algorithm that we're going to discuss is known as k means clustering what k means clustering is trying to do is it's trying to compute k clusters from the data so in this example below I have a bunch of scattered points and you'll see that this is at zero and x1 on the two axes which means I'm actually plotting two different features right of each point but we don't know what the y label is for those points and now just looking at these scattered points we can kind of see how there are different clusters in the data set right so depending on what we pick for k we might have different clusters let's say k equals two right then we might pick okay this seems like it could be one cluster but this here is also another cluster so those might be our two different clusters if we have k equals three for example then okay this seems like it could be a cluster this seems like it could be a cluster and maybe this could be a cluster right so we could have three different clusters in the data set now this k here is predefined if I can spell that correctly by the person who's running the model so that would be you all right and let's discuss how you know the computer actually goes through and computes the k clusters so I'm going to write those steps down here now the first step that happens is we actually choose the computer chooses three random points on this plot to be the centroids and by centroids I just mean the center of the clusters okay so three random points let's say we're doing k equals three so we're choosing three random points to be the the centroids of the three clusters if it were two we would be choosing two random points okay so maybe the three random points I'm choosing might be here here and here all right so we have three different points and the second thing that we do is we actually calculate the distance for each point to those centroids so between all the points and the centroids so basically I'm saying all right this is this distance this distance this distance all of these distances I'm computing between whoops not those two between the points not the centroids themselves so I'm computing the distances for all of these plots to each of the centroids okay and that comes with also assigning those points to the closest centroid what do I mean by that so let's take this point here for example so I'm computing this distance this distance and this distance and I'm saying okay it seems like the red one is the closest so I'm actually going to put this into the red centroid so if I do that for all of these points same slightly closer to red and this one seems slightly closer to red right now for the blue I actually wouldn't put any blue ones in here but we would probably actually that first one is closer to red and now it seems like the rest of them are probably closer to green so let's just put all of these into green here like that and cool so now we have are two three technically centroid so there's this group here there's this group here and then blue is kind of just this group here it hasn't really touched any of the points yet so the next step three that we do is we actually go and we recalculate the centroid so we compute new centroids based on the points that we have and all the centroids and by that I just mean okay well let's take the average of all these points and where is that new centroid that's probably going to be somewhere around here right the blue one we don't have any points and there so we won't touch and then the screen one we can put that probably somewhere over oops somewhere over here right so now if I race all of the previously computed centroids I can go and I can actually redo step two over here this calculation all right so I'm going to go back and I'm going to iterate through everything again and I'm going to recompute my three centroid so let's see we're going to take this red point these are definitely all red right this one still looks a bit red now this part we actually start getting closer to the blues so this one still seems closer to a blue than a green this one as well and I think the rest would belong to green okay so now our three centroids are three sorry our three clusters would be this and then this right those are our three centroids and so now we go back and we compute the new sorry those would be the three cluster so now we go back and we compute the three centroids so I'm going to get rid of this this and this and now where would this red be centered probably closer you know to this point here this blue might be closer to up here and then this green would probably be somewhere it's pretty similar to what we had before but it seems like it'd be pulled down a bit so probably somewhere around there for green all right and now again we go back and we compute the distance between all the points and the centroids and then we assign them to the closest centroid okay so the reds are all here it's very clear actually let me just circle that in this it actually seemed like this point is closer to this blue now so the blues seem like they would be maybe this point looks like it would be blue so all these look like they would be blue now and the greens would probably be this cluster right here so we go back we compute the centroids bam this one probably like almost here bam and then the green looks like it would be probably hereish okay and now we go back and we compute the we compute the clusters again so red still this blue I would argue is now this cluster here and green is this cluster here okay so we go and we recompute the centroid bam bam and bam and now if I were to go and assign all the points to clusters again I would get the exact same thing right and so that's when we know that we can stop iterating between steps two and three is one we've converged on some solution when we've reached some stable point and so now because none of these points are really changing out of their clusters anymore we can go back to the user and say hey these are our three clusters okay and this process something known as expectation maximization this part where we're assigning the points to the closest centroid this is something this is our expectation step and this part where we're computing the new centroids this is our maximization step okay so that's expectation maximization and we use this in order to compute the centroids assign all the points to clusters according to those centroids and then we're recomputing all that over again until we reach some stable point where nothing is changing anymore all right so that's our first example of unsupervised learning and basically what this is doing is trying to find some structure some pattern in the data so if I came up with another point you know might be somewhere here I can say oh it looks like that's closer to if this is a bc it looks like that's closest to cluster b and so I would probably put it in cluster b okay so we can find some structure in the data based on just how how the points are scattered relative to one another now the second unsupervised learning technique that I'm going to discuss with you guys something known as principle component analysis and the point of principle component analysis is very often it's used as a dimensionality reduction technique so let me write that down it's used for dimensionality reduction and what do I mean by dimensionality reduction is if I have a bunch of features like x1, x2, x3, x4 etc can I just reduce that down to one dimension that gives me the most information about how all these points are spread relative to one another and that's what pc a is for so pc a principle component analysis let's say I have some points in the x0 and x1 feature space okay so these points might be spread you know something like this okay so for example if this were something to do with housing prices right this here might be x0 might be hey years since built right since the house was built and x1 might be square footage of the house all right so like years since built I mean like right now it's been you know 22 years since a house in 2000 was built now principle component analysis is just saying all right let's say we want to build a model or let's say we want to you know display something about our data but we don't we don't have two axes to show it on how do we display you know how do we how do we demonstrate that this point is a further away from this point than this point and we can do that using principle component analysis so take what you know about linear regression and just forget about it for a second otherwise you might get confused pc a is a way of trying to find direction in the space with the largest variant so this principle component what that means is basically the component so some direction in this space with the largest variance okay it tells us the most about our data set without the two different dimensions like let's say we have these two different dimensions and somebody telling us hey you only get one dimension in order to show your data set what dimension like what do we do we want to project our data onto a single dimension all right so that in this case might be a dimension that looks something like this and you might say okay we're not going to talk about linear regression okay we don't have a y value so linear regression this would be y this is not y okay we don't have a label for that instead what we're doing is we're taking the right angle projection so all of these take that's not very visible but take this right angle projection onto this line and what pc a is doing is saying okay map all of these points onto this one dimensional space so the transformed data set would be here this one's on the data set to on the line so we just put that there but now this would be our new one dimensional data set okay it's not our prediction or anything this is our new data set if somebody came to us said you only get one dimension you only get one number to represent each of these two d points one number would you give me this would be the number that we gave okay this in this direction this is where our points are the most spread out right if I took this plot and let me actually duplicate this so I don't have to rewrite anything or so I don't have to erase and then redraw anything let me get rid of some of this stuff and I just got rid of a point third two so let me draw that back all right so if this were my original data point what if I had taken you know this to be the pc a dimension okay well I then would have points that let me actually do that in different color so if I were to draw a right angle to this for every point my points would look something like this and so just intuitively looking at these two different plots this top one and this one we can see that the points are squished a little bit closer together right which means at the variance that's not the space with the largest variance the thing about the largest variance is that this will give us the most discrimination between all of these points the larger the variance the further spread out these points will likely be now and so that's the that's the dimension that we should project it on a different way to actually look at that like what is the dimension with the largest variance it's actually it also happens to be the dimension that decreases that minimizes the residuals so if we take all the points and we take the residual from that the xy residual so in linear regression in linear regression we were looking only at this residual the differences between the predictions right between y and y hat it's not that here in principal component analysis we're taking the difference from our current point in two dimensional space and then it's projected point okay so we're taking that dimension and we're saying all right how much you know how much distance is there between that projection residual and we're trying to minimize that for all of these points so that actually equates to this largest variance dimension this dimension here the PCA dimension you can either look at it as minimizing minimized let me read it this the projection residuals so that's the stuff in orange or two maximizing the variance between the points okay and we're not really going to talk about you know the method that we need in order to calculate out the principal components or like what that projection would be because you will need to understand linear algebra for that especially eigenvectors and eigenvalues which I'm not going to cover in this class but that's how you would find the principal components okay now with this two dimensional data set here sorry this one dimensional data set we started from a two-day data set and we now boil it down to one dimension well we can go and take that dimension and we can do other things with it right we can like if there were a y label then we can now show x versus y rather than x zero and x one in different plots with that y we now we can just say oh this is a principal component and we're going to plot that with the y or for example if there were a hundred different dimensions and you only wanted to take five of them well you could go and you could find the top five PCA dimensions and that might be a lot more useful to you than one hundred different feature vector values right so that's principal component analysis again we're taking you know certain data that's unlabeled and we're trying to make some sort of estimation like some guess about it structure from that original data set if we wanted to take you know a 3D thing so like a sphere but we only have a 2D surface to draw it on well what's the best approximation that we can make oh it's a circle right PCA is kind of the same thing it's saying if we have something with all these different dimensions but we can't show all of them how do we boil it down to just one dimension how do we extract the most information from that multiple dimensions and that is exactly either you minimize the projection residuals or you maximize the variance and that is PCA so we'll go through an example of that now finally let's move on to implementing the unsupervised learning part of this class here again I'm on the UCI machine learning repository and I have a seeds dataset where you know I have a bunch of kernels that belong to three different types of wheat so there's comma roza and Canadian and the different features that we have access to are you know geometric parameters of those wheat kernels so the area perimeter compactness length width asymmetry and the length of the kernel groove okay so all these are real values which is easy to work with and what we're going to do is we're going to try to predict or I guess we're going to try to cluster the different varieties of the wheat so let's get started I have a colab notebook open again oh you're going to have to you know go to the data folder download this and let's get started so the first thing to do is to import our seed dataset into our colab notebook so I've done that here okay and then we're going to import all the classics again so pandas and then I'm also going to import seedborn because I'm going to want that for this specific class okay great so now our columns that we have in our seed dataset are the area the perimeter the compactness length width asymmetry groove length I mean I'm just going to call it groove and then the class right the wheat kernels class so now we have to import this I'm going to do that using pandas breed CSV and it's called seedsdata.csv so I'm going to turn that into a data frame and the names are able to the columns over here so what happens if I just do that oops what did I call the seeds dataset.text all right so if we actually look at our data frame right now you'll notice something funky okay and here you know we have all the stuff under area and these are all our numbers with some dashed heat so the reason is because we haven't actually told pandas what the separator is which we can do like this and this heat that's just a tab so in order to ensure that like all white space gets recognized as a separator we can actually this is for like a space so any spaces are going to get recognized as data separators so if I run that now our this you know this is a lot better okay okay so now let's actually go and like visualize this data so what I'm actually going to do is plot each of these against one another so in this case pretend that we don't have access to the class right pretend that so this class here I'm just going to show you in this example that like hey we can predict our class is using unsupervised learning but for this example in unsupervised learning we don't actually have access to the class so I'm going to just try to plot these against one another and see what happens so for some I in range you know the columns by one because the classes in the columns and I'm just going to say for J in range so take everything from I onwards you know so I like the next thing after I until the end of this so this will give us basically a grid of all the different like combinations and our x label is going to be columns i are y label is going to be the columns J so those are our labels up here and I'm going to use Cborn this time and I'm going to say scatter my data so our x is going to be our x label our y is going to be our y label and our data is going to be the data frame that we're passing in so what's interesting here is that we can say q and what this will do is say like if I give this class it's going to separate the three different classes into three different q so now what we're doing is we're basically comparing the area and the perimeter or the area and the compactness but we're going to visualize you know what classes they're in so let's go ahead and I might have to show so so great so basically we can see perimeter and area we give we get these three groups the area compactness we get these three groups and so on so these all kind of look honestly like somewhat similar right so well look at this one so this one we have the compactness in the asymmetry and it looks like there's not really I mean it just looks like there are blobs right sure maybe class three is over here more but one and two kind of look like they're on top of each other okay I mean there are some that might look slightly better in terms of clustering but let's go through some of the some of the clustering examples that we talked about and try to implement those the first thing that we're going to do is just straight up clustering so what we learned about was k means clustering so from SK learn I'm going to import k means okay and just for the sake of being able to run you know any x and any y I'm just going to say hey let's use some x let's a good one maybe mm mm I mean perimeter asymmetry could be a good one so x could be perimeter y could be asymmetry okay and for this the x values I'm going to just extract those specific values all right well let's make a k means uh algorithm or let's you know define this so k means and in this specific case we know that the number of clusters is three so let's just use that and I'm going to fit this against this x that I've just defined right here all right so um you know if I create this clusters so one thing one cool thing is I can actually go to this clusters and I can say k means that labels and it'll give give me if I can type correctly it'll give me what its predictions for all the clusters are and our actual oops not that um if we go to the data frame and we get the class and the values from those we can actually compare these two and say hey like you know everything in general most of the zeros that it's predicted are the ones right and in general the twos are the twos here and then the third class one okay that course wants to three now remember these are separate classes so the labels what we actually call them don't really matter we can say of map 0 to 1 map 2 to 2 and map 1 to 3 okay and our you know are mapping would do fairly well but we can actually visualize this and in order to do that I'm going to create this cluster cluster data frame so I'm going to create a data frame and I'm going to pass in a course on to a stacked array with x so my values for x and y and then the clusters that I have here but I'm going to reshape them so it's 2d okay and the columns the labels for that are going to be x, y and plus okay so I'm going to go ahead and do that same C-born scatter plot again where x is x, y is y and now the hue is again the class and the data is now this cluster data frame all right so this here this here is my k means like I guess classes so k means kind of looks like this if I come down here and I plot you know my original data frame this is my original classes with respect to this specific x and y and you'll see that honestly like it doesn't do too poorly yeah there's I mean the colors are different but that's fine for the most part it gets information of the clusters right and now we can do that with higher dimensions so with the higher dimensions if we make x equal to you know all the columns except for the last one which is our class we can do the exact same thing so here and we can then predict this but now our columns are equal to our data frame columns all the way to the last one and then with this class actually so we can literally say data frame columns and we can fit all of this and now if I want to plot the k means classes all right so this was my that's my clustered and my original so actually let me see if I can get these on the same page so yeah I mean pretty similar to what we just saw but what's actually really cool is even something like you know if we change so what's one of them where they were like on top of each other oh okay so compactness and asymmetry this one's a messy right so if I come down here and I say compactness and asymmetry and I'm trying to do this in 2D this is what my scatterflow so this is what you know my k means is telling me for these two dimensions for compactness and asymmetry if we just look at those two these are our three classes right and we know that the original looks something like this and are these two remotely alike no okay so now if I come back down here and I rerun this hired dimensions one but actually this clusters I need to get the labels of the k means again okay so if I rerun this with hired dimensions well if we zoom out and we take a look at these two sure the colors are mixed up but in general the three groups are there right this does a much better job at assessing okay what group is what so for example we could label the one in the original class to two and then we could make sorry okay this is kind of confusing but for example if this light pink were projected onto this darker pink here and then this dark one was actually the light pink and this light one was this dark one then you kind of see you like these correspond to one another right like even these two up here are the same classes all the other ones over here which are the same in the same color so you don't want to compare the two colors between the plots you want to compare which points are in what colors in each of the plots so that's one cool application so this is how k means functions it's basically taking all the data sets and saying are where are my clusters given these pieces of data and then the next thing that we talked about is PCA so PCA were reducing the dimension but we're mapping all these like you know seven dimensions I don't know if there are seven that I made that number up but we're we're mapping multiple dimensions into a lower dimension number right and so let's see how that works so from SK learn decomposition I can import PCA and that will be my PCA model so if I do PCA component so this is how many dimensions you want to map it into and you know for the exercise let's do two okay so now I'm taking the top two dimensions and my transformed x is going to be PCA dot fit transform and the same x that I had up here okay so all the other values basically area perimeter compactness length with a symmetry groove okay so let's run that and we've transformed it so let's look at what the shape of x used to be so they're okay so seven was right I had 210 samples each seven seven features long basically and now my transformed x is 210 samples but only of length two which means that I only have two dimensions now that I'm plotting and we can actually even take a look at you know the first five things okay so now we see each each one is a two dimensional point each sample is now two dimensional point and our new um and our new dimensions so what's cool is I can actually scatter these 0 and transformed x so I actually have to take the columns here and if I show that basically we've just taken this like seven dimensional thing and we've made it into a single or I guess two two dimensional representation so that's a point of PCA and actually let's go ahead and do the same clustering exercise as we did up here if I take the uh canines this PCA data frame I can let's come struck data frame out of that and the data frame is going to be hstack I'm going to take this transformed x and the clusters that are shaped so actually instead of clusters I'm going to use camines dot labels and I need to reshape this so it's 2D so we can do the hstack um and for the columns I'm going to set this to PCA 1 PCA 2 and the class right so now if I take this I can also do the same for the truth but instead of the camines labels I want from the data frame the original classes and I'm just going to take the values from that and so now I have a data frame for the camines with PCA and then a data frame for the truth with also the PCA and I can now plot these similarly to how I plotted these up here so let me actually take these two and set the cluster data frame I want the uh this is the camines PCA data frame this is still going to be class but now x and y are going to be the 2 PCA dimensions okay so these are my 2 PCA dimensions and you can see that you know they're they're pretty spread it and then here I'm going to go to my truth classes again it's PCA 1 PCA 2 but instead of camines this should be truth PCA data frame so you can see that like in the truth data frame uh along these two dimensions we actually are doing fairly well in terms of separation right it does seem like this is slightly more separable than the other like dimensions that we had been looking at up here so that's a good sign um and up here you can see that hey some of these correspond to one another I mean for the most part our algorithm our unsupervised clustering algorithm is able to give us is able to spit out you know what the proper uh labels are I mean if you map these specific labels to the different types of kernels but for example this one might all be the like comic kernel kernels and same here and then these might all be the Canadian kernels and these might all be the Canadian kernels so it does struggle a little bit with you know where they overlap but for the most part our algorithm is able to find the three different categories and do a fairly good job at predicting them without without any information from us we haven't given our algorithm any labels so that's a just of unsupervised learning I hope you guys enjoyed this course I hope you know a lot of these examples made sense um if there are certain things that I have done and you know you're somebody with more experience of me please feel free to correct me in the comments and we can all as a community learn from this together so thank you all for watching